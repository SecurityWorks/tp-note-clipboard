.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "TP-NOTE" "1" "2023-10-06" "Version 1.22.6" "Tp-Note documentation"
.hy
.SH NAME
.PP
\f[I]Tp-Note\f[R] - save and edit your clipboard content as a note file.
.SH SYNOPSIS
.IP
.nf
\f[C]
tpnote [-a ] [-b] [-c <FILE>] [-d <LEVEL>] [-e] [-l <LANG>]
       [-p <NUM>] [-n] [-t] [-u] [-v] [-V] [-x <DIR>|\[aq]\[aq]|\[aq]-\[aq]]
       [<DIR>|<FILE>]
\f[R]
.fi
.SH DESCRIPTION
.PP
Tp-Note is a note-taking tool and a template system, that synchronizes
the note\[cq]s metadata with its filename.
Tp-Note analyses its environment and the clipboard content and stores
the result in variables.
New notes are created by filling these variables in predefined and
customizable \f[I]Tera\f[R]-templates.
In case the first positional parameter `\f[V]<FILE>\f[R]' points to an
existing Tp-Note file, the note\[cq]s metadata is parsed and, if
necessary, its filename is adjusted.
For all other file types, Tp-Note creates a new note in the same
directory annotating the file.
If the positional parameter `\f[V]<DIR>\f[R]' points to an existing
directory (or, when omitted, the current working directory), a new note
is created in that directory.
After creation, Tp-Note launches the systems file editor.
Although the configurable default templates are written for Markdown,
Tp-Note is not tied to any specific markup language.
However, Tp-Note comes with an optional viewer feature, that currently
renders only Markdown, ReStructuredText and HTML input.
In addition, there is some limited support for Asciidoc and WikiText.
Finally, the note\[cq]s rendition is live updated and displayed in the
user\[cq]s web browser.
.PP
After the user finished editing, Tp-Note analyses potential changes in
the notes metadata and renames, if necessary, the file, so that its
metadata and filename are in sync again.
Finally, the resulting path is printed to `\f[V]stdout\f[R]', log and
error messages are dumped to `\f[V]stderr\f[R]'.
.PP
This document is Tp-Note\[cq]s technical reference.
More information can be found in Tp-Note\[cq]s user
manual (https://blog.getreu.net/projects/tp-note/tpnote--manual.html)
and at Tp-Note\[cq]s project
page (https://blog.getreu.net/projects/tp-note/).
.SH OPERATION MODES
.PP
Tp-Note operates in 5 different modes, depending on its command line
arguments and the clipboard state.
Each mode is associated with one content template and one filename
template.
.SS Create a new note with empty clipboard
.PP
In case the clipboard is empty while starting, the new note is created
with the templates: `\f[V]tmpl.new_content\f[R]' and
`\f[V]tmpl.new_filename\f[R]'.
By default, the new note\[cq]s title is the parent\[cq]s directory name.
The newly created file is then opened with an external text editor,
allowing it to change the proposed title and add other content.
When the text editor closes, Tp-Note synchronizes the note\[cq]s
metadata and its filename.
This operation is performed with the `\f[V]tmpl.sync_filename\f[R]'
template.
.PP
Example: the clipboard is empty and `\f[V]<path>\f[R]' is a directory
(or empty):
.IP
.nf
\f[C]
tpnote \[dq]./03-Favorite Readings/\[dq]
\f[R]
.fi
.PP
or
.IP
.nf
\f[C]
cd \[dq]./03-Favorite Readings\[dq]
tpnote
\f[R]
.fi
.PP
creates the document:
.IP
.nf
\f[C]
\&./03-Favorite Readings/20211031-Favorite Readings--Note.md
\f[R]
.fi
.PP
with the content:
.IP
.nf
\f[C]
---
title:      Favorite Readings
subtitle:   Note
author:     Getreu
date:       2021-10-31
lang:       en-GB
---
\f[R]
.fi
.SS Create a new note based on clipboard data
.PP
When `\f[V]<path>\f[R]' is a directory and the clipboard is not empty,
the clipboard\[cq]s content is stored in the variable
`\f[V]{{ clipboard }}\f[R]'.
In addition, if the content contains an hyperlink in Markdown format,
the hyperlink\[cq]s name can be accessed with
`\f[V]{{ clipboard | link_text }}\f[R]', its URL with
`\f[V]{{ clipboard | link_dest }}\f[R]' and its title with
`\f[V]{{ clipboard | link_title }}\f[R]'.
The new note is then created with the
`\f[V]tmpl.from_clipboard_content\f[R]' and the
`\f[V]tmpl.from_clipboard_filename\f[R]' templates.
Finally, the newly created note file is opened again with some external
text editor.
When the user closes the text editor, Tp-Note synchronizes the
note\[cq]s metadata and its filename with the template
`\f[V]tmpl.sync_filename\f[R]'.
.PP
Note: this operation mode also empties the clipboard (configurable
feature).
.PP
\f[B]Clipboard simulation\f[R]
.PP
When no mouse and clipboard is available, the clipboard feature can be
simulated by feeding the clipboard data into \f[V]stdin\f[R]:
.IP
.nf
\f[C]
echo \[dq][The Rust Book](<https://doc.rust-lang.org/book/>)\[dq] | tpnote
\f[R]
.fi
.PP
Tp-Note behaves here as if the clipboard contained the string:
\[lq]\f[V][The Rust Book](<https://doc.rust-lang.org/book/>)\f[R]\[rq].
.SS The clipboard contains a string
.PP
Example: While launching Tp-Note the clipboard contains the string:
\[lq]\f[V]Who Moved My Cheese?\[rs]n\[rs]nChapter 2\f[R]\[rq] and
`\f[V]<path>\f[R]' is a directory.
.IP
.nf
\f[C]
tpnote \[dq]./03-Favorite Readings/\[dq]
\f[R]
.fi
.PP
or
.IP
.nf
\f[C]
cd \[dq]./03-Favorite Readings/\[dq]
tpnote
\f[R]
.fi
.PP
This creates the document:
.IP
.nf
\f[C]
\&./03-Favorite Readings/20211031-Who Moved My Cheese--Note.md
\f[R]
.fi
.PP
with the content:
.IP
.nf
\f[C]
---
title:      Who Moved My Cheese
subtitle:   Note
author:     Getreu
date:       2021-10-31
lang:       en-GB
---

Who Moved My Cheese?

Chapter 2
\f[R]
.fi
.PP
We see from the above example, how the
`\f[V]tmpl.from_clipboard_content\f[R]' content template extracts the
first line of the clipboards content and inserts it into the
header\[cq]s `\f[V]title:\f[R]' field.
Then, it copies the entire clipboard content into the body of the
document.
However, if desired or necessary, it is possible to modify all templates
in Tp-Note\[cq]s configuration file.
Note, that not only the note\[cq]s content is created with a template,
but also its filename: The `\f[V]tmpl.from_clipboard_filename\f[R]'
filename template concatenates the current date, the note\[cq]s title
and subtitle.
.SS The clipboard contains a hyperlink
.PP
Example: `\f[V]<path>\f[R]' is a directory, the clipboard is not empty
and it contains the string:
`\f[V]I recommend:\[rs]n[The Rust Book](https://doc.rust-lang.org/book/)\f[R]'.
.IP
.nf
\f[C]
tpnote \[aq]./doc/Lecture 1\[aq]
\f[R]
.fi
.PP
Tp-Note\[cq]s templates `\f[V]tmpl.from_clipboard_content\f[R]' and
`\f[V]tmpl.from_clipboard_filename\f[R]' create the following document:
.IP
.nf
\f[C]
\&./doc/Lecture 1/20211031-The Rust Book--Notes.md
\f[R]
.fi
.IP
.nf
\f[C]
---
title:      The Rust Book
subtitle:   URL
author:     Getreu
date:       2021-10-31
lang:       en-GB
---

I recommend:
[The Rust Book](<https://doc.rust-lang.org/book/>)
\f[R]
.fi
.PP
When analyzing the clipboard\[cq]s content, Tp-Note searches for
hyperlinks in Markdown, ReStructuredText, Asciidoc and HTML format.
When successful, the content template uses the link text of the first
hyperlink found as document title.
.SS The clipboard contains a string with a YAML header
.PP
Example: `\f[V]<path>\f[R]' is a directory, the clipboard is not empty
and contains the string:
`\f[V]---\[rs]ntitle: Todo\[rs]nfile_ext: mdtxt\[rs]n---\[rs]nnothing\f[R]'.
.IP
.nf
\f[C]
tpnote
\f[R]
.fi
.PP
This creates the note: `\f[V]20230915-Todo.mdtxt\f[R]' with the
following content:
.IP
.nf
\f[C]
---
title:      Todo
subtitle:   Note
author:     Getreu
date:       2023-09-15
lang:       fr-FR

file_ext:   mdtxt
---

nothing
\f[R]
.fi
.PP
Technically, the creation of the new note is performed using the YAML
header variables: `\f[V]{{ fm_title }}\f[R]',
`\f[V]{{ fm_subtitle }}\f[R]', `\f[V]{{ fm_author }}\f[R]',
`\f[V]{{ fm_date }}\f[R]', `\f[V]{{ fm_lang }}\f[R]',
`\f[V]{{ fm_sort_tag }}\f[R]' and `\f[V]{{ fm_file_ext }}\f[R]' which
are evaluated with the `\f[V]tmpl.from_clipboard_yaml_content\f[R]' and
the `\f[V]tmpl.from_clipboard_yaml_filename\f[R]' templates.
.PP
Note, that the same result can also be achieved without clipboard input
by typing in a terminal:
.IP
.nf
\f[C]
echo -e \[dq]---\[rs]ntitle: Todo\[rs]nfile_ext: mdtxt\[rs]n---\[rs]n\[rs]nnothing\[dq] | tpnote
\f[R]
.fi
.PP
Furthermore, this operation mode is very handy with pipes in general, as
shows the following example: it downloads some webpage, converts it to
Markdown and copies the result into a Tp-Note file.
The procedure preserves the webpage\[cq]s title in the note\[cq]s title:
.IP
.nf
\f[C]
curl \[aq]https://blog.getreu.net\[aq] \[rs]
| pandoc --standalone -f html -t markdown_strict+yaml_metadata_block \[rs]
| tpnote
\f[R]
.fi
.PP
creates the note file
`\f[V]20230919-Jens Getreu\[aq]s blog--Note.md\f[R]' with the
webpage\[cq]s content converted to Markdown:
.IP
.nf
\f[C]
---
title:      Jens Getreu\[aq]s blog
subtitle:   Note
author:     Getreu
date:       2023-09-15
lang:       en

viewport:   width=device-width, initial-scale=1.0, maximum-scale=1
---

<a href=\[dq]/\[dq] class=\[dq]logo\[dq]>Jens Getreu\[aq]s blog</a>

-   [Home](https://blog.getreu.net)
-   [Categories](https://blog.getreu.net/categories)
\f[R]
.fi
.SS Create a new note annotating a non Tp-Note file
.PP
When `\f[V]<path>\f[R]' points to an existing file, whose file extension
is other than `\f[V].md\f[R]', a new note is created with a similar
filename and a reference to the original file is copied into the new
note\[cq]s body.
If the clipboard contains some text, it is appended there also.
The logic of this is implemented in the templates:
`\f[V]tmpl.annotate_file_content\f[R]' and
`\f[V]tmpl.annotate_file_filename\f[R]'.
Once the file is created, it is opened with an external text editor.
After editing the file, it will be - if necessary - renamed to be in
sync with the note\[cq]s metadata.
.PP
Example:
.IP
.nf
\f[C]
:> \[dq]Classic Shell Scripting.pdf\[dq]

tpnote \[dq]Classic Shell Scripting.pdf\[dq]
\f[R]
.fi
.PP
creates the note:
.IP
.nf
\f[C]
Classic Shell Scripting.pdf--Note.md\[dq]
\f[R]
.fi
.PP
with the content:
.IP
.nf
\f[C]
---
title:      Classic Shell Scripting.pdf
subtitle:   Note
author:     Getreu
date:       2023-09-15
lang:       en-US
---

[Classic Shell Scripting.pdf](<Classic Shell Scripting.pdf>)
\f[R]
.fi
.PP
The configuration file variable `\f[V]filename.extensions\f[R]' list all
the file extensions that Tp-Note recognizes as own file types.
Only foreign file types can be annotated.
.PP
Note that the file annotation mode also reads the clipboard\[cq]s
content: when it is not empty, its data is appended to the new
note\[cq]s body.
.SS Convert a text file into a Tp-Note file
.PP
Consider the content of the following text file
`\f[V]Ascii-Hangman--A game for children.md\f[R]' whose creation date is
13 March 2022:
.IP
.nf
\f[C]
A little game designed for primary kids to revise vocabulary in classroom.
\f[R]
.fi
.PP
To convert the text file into a Tp-Note file type:
.IP
.nf
\f[C]
tpnote --add-header --batch \[dq]Ascii-Hangman--A game for children.md\[dq]
\f[R]
.fi
.PP
NB: the `\f[V]--add-header\f[R]' flag is actually not necessary, as it
is enabled by default through the configuration file variable
`\f[V]arg_default.add_header = true\f[R]'.
.PP
As a result of the above command, Tp-Note converts the filename into:
.IP
.nf
\f[C]
20220313-Ascii-Hangman--A game for children.md
\f[R]
.fi
.PP
and prepends a YAML header to the file\[cq]s content:
.IP
.nf
\f[C]
---
title:      Ascii-Hangman
subtitle:   A game for children
author:     Getreu
date:       2022-03-13
lang:       en-US

orig_name:  Ascii-Hangman--A game for children.md
---

A little game designed for primary kids to revise vocabulary in classroom.
\f[R]
.fi
.SS Use Tp-Note in shell scripts
.IP \[bu] 2
\f[B]Use case: download a webpage and store it as Tp-Note file\f[R]
.RS 2
.PP
Using the method displayed above you can save time and create a script
with:
.IP
.nf
\f[C]
sudo nano /usr/local/bin/download
\f[R]
.fi
.PP
Insert the following content:
.IP
.nf
\f[C]
#!/bin/sh
curl \[dq]$1\[dq] | pandoc --standalone -f html -t markdown_strict+yaml_metadata_block | tpnote
\f[R]
.fi
.PP
and make it executable:
.IP
.nf
\f[C]
sudo chmod a+x /usr/local/bin/download
\f[R]
.fi
.PP
To execute the script type:
.IP
.nf
\f[C]
download \[aq]https://blog.getreu.net\[aq]
\f[R]
.fi
.RE
.IP \[bu] 2
\f[B]Use case: synchronize recursively filenames and metadata\f[R]
.RS 2
.PP
The following synchronizes bidirectionally all filenames with the
note\[cq]s YAML header data.
.IP
.nf
\f[C]
TPNOTE_USER=\[dq]John\[dq] find . -type f -name \[aq]*.md\[aq] -exec tpnote -a -b {} > /dev/null \[rs];
\f[R]
.fi
.PP
The direction of the synchronization depends on whether the
`\f[V].md\f[R]' file has a valid YAML header or not:
.IP \[bu] 2
A YAML header is present and valid: the header fields might update the
filename (see template `\f[V]tmpl.sync_filename\f[R]').
A possible \f[I]sort-tag\f[R] at the beginning of the filename remains
untouched.
.IP \[bu] 2
No YAML header: a new header is prepended (see template
`\f[V]from_text_file_content\f[R]') and the filename might change
slightly (see template `\f[V]from_text_file_filename\f[R]').
A possible \f[I]sort-tag\f[R] at the beginning of the filename remains
untouched.
If the filename does not start with a sort tag, the file\[cq]s creation
date is prepended.
.RE
.SS Editing notes
.PP
Unless invoked with `\f[V]--batch\f[R]' or `\f[V]--view\f[R]', Tp-Note
launches an external text editor after creating a new note.
This also happens when `\f[V]<path>\f[R]' points to an existing
`\f[V].md\f[R]'-file.
.PP
Example: edit the note from the previous example:
.IP
.nf
\f[C]
cd \[dq]./03-Favorite Readings\[dq]
tpnote 20211031-Favorite Readings--Note.md
\f[R]
.fi
.SS Automatic filename synchronization before and after editing
.PP
Before launching the text editor and after closing it, Tp-Note
synchronizes the filename with the note\[cq]s metadata.
When the user changes the metadata of a note, Tp-Note will replicate
that change in the note\[cq]s filename.
As a result, \f[I]all your note\[cq]s filenames always correspond to
their metadata\f[R], which helps to retrieve your notes in large data
pools.
.PP
Example:
.IP
.nf
\f[C]
tpnote \[dq]20200306-Favorite Readings--Note.md\[dq]
\f[R]
.fi
.PP
The way how Tp-Note synchronizes the note\[cq]s metadata and filename is
defined in the template `\f[V]tmpl.sync_filename\f[R]'.
.PP
Once Tp-Note opens the file in your text editor, let\[cq]s assume you
decide to change the title in the note\[cq]s YAML metadata section from
`\f[V]title: Favorite Readings\f[R]' to
`\f[V]title: Introduction to bookkeeping\f[R]'.
After closing the text editor, Tp-Note updates the filename
automatically:
.IP
.nf
\f[C]
20200306-Introduction to bookkeeping--Note.md
\f[R]
.fi
.PP
Note: the sort tag `\f[V]20200306\f[R]' has not changed.
The filename synchronization mechanism by default never does.
(See below for more details about filename synchronization).
.SH OPTIONS
.PP
\f[B]-a\f[R], \f[B]--add-header\f[R]
.RS
.PP
Prepend a YAML header in case the text file does not have one.
The default template, deduces the `\f[V]title:\f[R]' and
`\f[V]subtitle:\f[R]' header field from the filename.
It\[cq]s sort-tag and file extension remain untouched.
In case the filename is lacking a \f[I]sort-tag\f[R], the file creation
date in numerical format is prepended.
As this option is activated by default, it has no effect unless you set
`\f[V]arg_default.add_header = false\f[R]' in the configuration file.
.RE
.PP
\f[B]-b\f[R], \f[B]--batch\f[R]
.RS
.PP
Do not launch the external text editor or viewer.
All other operations are available and are executed in the same way.
In batch mode, error messages are dumped on the console only and no
alert windows pop up.
.RE
.RS
.PP
Tp-Note ignores the clipboard when run in batch mode with
`\f[V]--batch\f[R]'.
Instead, if available, it reads the \f[V]stdin\f[R] stream as if the
data came from the clipboard.
.RE
.PP
\f[B]-c\f[R] \f[I]FILE\f[R], \f[B]--config\f[R]=\f[I]FILE\f[R]
.RS
.PP
Load the alternative config file \f[I]FILE\f[R] instead of the default
one.
.RE
.PP
\f[B]-d\f[R] \f[I]LEVEL\f[R], \f[B]--debug\f[R]=\f[I]LEVEL\f[R]
.RS
.PP
Print additional log messages.
The debug level \f[I]LEVEL\f[R] must be one out of `\f[V]trace\f[R]',
`\f[V]debug\f[R]', `\f[V]info\f[R]', `\f[V]warn\f[R]', `\f[V]error\f[R]'
(default) or `\f[V]off\f[R]'.
The level `\f[V]trace\f[R]' reports the most detailed information, while
`\f[V]error\f[R]' informs you only about failures.
A `\f[V]warn\f[R]' level message means, that not all functionality might
be available or work as expected.
.RE
.RS
.PP
Use `\f[V]-b -d trace\f[R]' for debugging templates.
If the HTTP server (viewer) does not work as expected:
`\f[V]-n -d debug\f[R]'.
If your text editor does not open as expected:
`\f[V]-n -d info --edit\f[R]'.
Or, to observe the launch of the web browser:
`\f[V]-n -d info --view\f[R]'.
The option `\f[V]-d trace\f[R]' shows all available template variables,
the templates used and the rendered result of the substitution.
This is particularly useful for debugging new templates.
The option `\f[V]-d off\f[R]' silences all error message reporting and
also suppresses the error pop-up windows.
.RE
.RS
.PP
Note, under Linux, when \f[V]-d trace\f[R] is given, no pop-up messages
appear.
Instead, the logs are dumped to the console from where you started
Tp-Note.
.RE
.RS
.PP
All error messages are dumped in the error stream \f[V]stderr\f[R] and
appear on the console from where Tp-Note was launched:
.RE
.IP
.nf
\f[C]
    tpnote.exe --debug info my_note.md
\f[R]
.fi
.RS
.PP
Under Windows the output must be redirected into a file to see it:
.RE
.IP
.nf
\f[C]
    tpnote.exe --debug info my_note.md >debug.md 2>&1
\f[R]
.fi
.RS
.PP
Alternatively, you can redirect all log file entries into popup alert
windows.
.RE
.IP
.nf
\f[C]
    tpnote.exe --popup --debug info my_note.md
\f[R]
.fi
.RS
.PP
The same can be achieved by setting following configuration file
variables (especially useful with Windows):
.RE
.IP
.nf
\f[C]
    [arg_default]
    debug = \[aq]info\[aq]
    popup = true
\f[R]
.fi
.RS
.PP
The value for `\f[V]arg_default.debug\f[R]' must be one out of
`\f[V]trace\f[R]', `\f[V]debug\f[R]', `\f[V]info\f[R]',
`\f[V]warn\f[R]', `\f[V]error\f[R]' (default) and `\f[V]off\f[R]'.
They have the same meaning as the corresponding command line options.
.RE
.PP
\f[B]-e\f[R], \f[B]--edit\f[R]
.RS
.PP
Edit only mode: opens the external text editor, but not the file viewer.
This disables Tp-Note\[cq]s internal file watcher and web server, unless
`\f[V]-v\f[R]' is given.
Alternatively you can set the environment variable
`\f[V]TPNOTE_BROWSER=\[dq]\[dq]\f[R]' to the empty string.
Another way to permanently disable the web server is to set the
configuration variable `\f[V]arg_default.edit=true\f[R]'.
When `\f[V]--edit --view\f[R]' appear together, both the editor and the
viewer will open and the \f[V]arg_default.edit\f[R] variable is ignored.
.RE
.PP
\f[B]-l\f[R] \f[I]LANGUAGE_TAG\f[R],
\f[B]--force-lang\f[R]=\f[I]LANGUAGE_TAG\f[R]
.RS
.PP
Disables the automatic language detection while creating a new note file
and use \f[I]LANGUAGE_TAG\f[R] instead.
\f[I]LANGUAGE_TAG\f[R] is formatted as IETF BCP 47 language tag,
e.g.\ `\f[V]en-US\f[R]'.
If \f[I]LANGUAGE_TAG\f[R] equals `\f[V]-\f[R]', the environment variable
`\f[V]TPNOTE_LANG\f[R]' determines the language instead; or, if the
latter is not defined, the user\[cq]s default language, as reported from
the operating system\[cq]s locale setting, is decisive.
.RE
.PP
\f[B]-p\f[R] \f[I]PORT\f[R], \f[B]--port\f[R]=\f[I]PORT\f[R]
.RS
.PP
Sets the server port that the web browser connects to, to the specified
value \f[I]PORT\f[R].
If not given, a random available port is chosen automatically.
.RE
.PP
\f[B]-n\f[R], \f[B]--no-filename-sync\f[R]
.RS
.PP
Whenever Tp-Note opens a note file, it synchronizes its YAML-metadata
with its filename.
`\f[V]--no-filename-sync\f[R]' disables this synchronization.
In addition, in scripts this flag can be especially useful for
validating the syntax of `\f[V].md\f[R]'-files.
See section EXIT STATUS for more details.
The section METADATA FILENAME SYNCHRONIZATION shows alternative ways to
disable synchronization.
.RE
.PP
\f[B]-t\f[R], \f[B]--tty\f[R]
.RS
.PP
Tp-Note tries different heuristics to detect whether a graphic
environment is available or not.
For example, under Linux, the `\f[V]DISPLAY\f[R]' environment variable
is evaluated.
The `\f[V]--tty\f[R]' flag disables the automatic detection and sets
Tp-Note into \[lq]console only\[rq] mode: now only the non GUI editor
(see configuration variable: `\f[V]app_args.editor_console\f[R]') and no
viewer is launched.
.RE
.PP
\f[B]-u\f[R], \f[B]--popup\f[R]
.RS
.PP
Redirect log file entries into popup alert windows.
Must be used together with the \f[B]--debug\f[R] option to have an
effect.
Note, that debug level `\f[V]error\f[R]' conditions will always trigger
popup messages, regardless of \f[B]--popup\f[R] and \f[B]--debug\f[R]
(unless `\f[V]--debug off\f[R]').
Popup alert windows are queued and will never interrupt Tp-Note.
To better associate a particular action with its log events, read
through all upcoming popup alert windows until they fail to appear.
.RE
.PP
\f[B]-v\f[R], \f[B]--view\f[R]
.RS
.PP
View only mode: do not open the external text editor.
This flag instructs Tp-Note to start an internal file watcher and web
server and connect the system\[cq]s default web browser to view the note
file and to observe live file modifications.
The configuration setting `\f[V]arg_default.edit=true\f[R]' or the
environment variable `\f[V]TPNOTE_EDITOR=\[dq]\[dq]\f[R]' disables the
viewer.
However, with `\f[V]--view\f[R]' given at the command line, the viewer
appears, regardless of the value of `\f[V]arg_default.edit\f[R]'.
.RE
.RS
.PP
As most users do not expect the viewed file to change,
`\f[V]--view\f[R]' is usually used together with
`\f[V]--no-filename-sync\f[R]'.
.RE
.PP
\f[B]-V\f[R], \f[B]--version\f[R]
.RS
.PP
Print Tp-Note\[cq]s version, its built-in features and the path to the
sourced configuration file.
The output is YAML formatted for further automatic processing.
.RE
.PP
\f[B]-x\f[R] \f[I]DIRECTORY\f[R], \f[B]--export\f[R]=\f[I]DIRECTORY\f[R]
.RS
.PP
Print the note as HTML rendition into \f[I]DIRECTORY\f[R].
`\f[V]-x -\f[R]' prints to \f[I]stdout\f[R].
The empty string, e.g.\ `\f[V]--export=\f[R]' or
`\f[V]-x \[dq]\[dq]\f[R]', defaults to the directory where the note file
resides.
No external text editor or viewer is launched.
Can be combined with `\f[V]--batch\f[R]' to avoid popup error alert
windows.
.RE
.PP
\f[B]--export-link-rewriting\f[R]=\f[I]MODE\f[R]
.RS
.PP
Choose how local links in the exported HTML file are written out:
`\f[V]off\f[R]', `\f[V]short\f[R]' or `\f[V]long\f[R]' (default).
No link rewriting occurs, for the \f[I]MODE\f[R] `\f[V]off\f[R]'.
The \f[I]MODE\f[R] `\f[V]short\f[R]' rewrites all local relative links
to absolute links, whose base is the first parent directory containing
the marker file `\f[V].tpnote.toml\f[R]' (filename customizable).
NB, the directory of the marker file defines the base for all absolute
local links in your Tp-Note file!
The mode `\f[V]long\f[R]' rewrites \f[I]all\f[R] local links to absolute
links whose base is the system\[cq]s root directory `\f[V]/\f[R]'.
For relative local links this is performed by prepending the path to the
note file.
Absolute local links get the path to the marker file
`\f[V].tpnote.toml\f[R]' prepended.
In case you do not place a `\f[V].tpnote.toml\f[R]' file in a parent
directory, the base for absolute local links in your note file is
interpreted as `\f[V]/\f[R]'.
The right mode to choose depends on how you view the resulting HTML: if
you publish on a web server, then `\f[V]short\f[R]' is a good choice.
If you view the HTML file directly in your web browser, better choose
`\f[V]long\f[R]'.
NB: You can also set this option via Tp-Note\[cq]s configuration file
with the key `\f[V]arg_default.export_link_rewriting\f[R]'.
.RE
.SH THE NOTE\[cq]S DOCUMENT STRUCTURE
.PP
Tp-Note considers a text file to be a valid note file, if its:
.IP \[bu] 2
file extension is listed in one of the configuration file variables
`\f[V]filename.extension_*\f[R]'; if its
.IP \[bu] 2
content has a valid YAML header and
.IP \[bu] 2
the YAML header contains a key whose name is defined in the
configuration file variable `\f[V]tmpl.compulsory_header_field\f[R]'
(default `\f[V]title\f[R]').
.PP
A Tp-Note note file is always UTF-8 encoded.
As newline, either the Unix standard `\f[V]\[rs]n\f[R]' or the Windows
standard `\f[V]\[rs]r\[rs]n\f[R]' is accepted.
Tp-Note writes out newlines according the operating system it runs on.
.SS The document\[cq]s header and body
.PP
Tp-Note is designed to be compatible with `\f[V]Pandoc\f[R]\[cq]s
and'\f[V]RMarkdown\f[R]s document structure as shown in the figure
below.
In this documentation the terms \[lq]YAML header\[rq], \[lq]header\[rq]
and \[lq]front matter\[rq] are used as synonyms to designate to
document\[cq]s metadata block at the beginning of the text file:
.IP
.nf
\f[C]
---
<YAML-front-matter>
---

<document-body>
\f[R]
.fi
.PP
The YAML front-matter starts at the beginning of the document with
`\f[V]---\f[R]' and ends with `\f[V]...\f[R]' or `\f[V]---\f[R]'.
Note that according to the YAML standard, string literals are always
encoded as JSON strings.
By convention, a valid Tp-Note file has at least one YAML field named
`\f[V]title:\f[R]' (the name of this compulsory field is defined by the
`\f[V]tmpl.compulsory_header_field\f[R]' variable in the configuration
file and can be changed there).
.PP
Note that prepended text, placed before the YAML front-matter, is
ignored.
There are however certain restrictions: If present, the skipped text
should not be too long (cf.\ constant
`\f[V]BEFORE_HEADER_MAX_IGNORED_CHARS\f[R]' in the source code of
Tp-Note) and it must be followed by at least one blank line:
.IP
.nf
\f[C]
Prepended text is ignored.

---
<YAML-front-matter>
---

<document-body>
\f[R]
.fi
.PP
There is no restriction about the markup language being used in the
note\[cq]s text body.
However, the default templates assume Markdown and the file extension
`\f[V].md\f[R]'.
Both can be changed easily by adapting Tp-Note\[cq]s configuration file.
Besides the requirements concerning its header, a valid Tp-Note file
must have a filename extension that is listed in one of the
configuration file variables: `\f[V]filename.extension_*\f[R]'.
The latter also determine which internal markup language render is
called for Tp-Note\[cq]s internal viewer.
.SS Links to resources and other documents
.PP
The document\[cq]s body often contains (inline) links to resources
e.g.\ images and links to other documents.
The link syntax depends on the markup language used in the Tp-Note file.
.PP
Here some example links in Markdown notation:
.IP \[bu] 2
A website: `\f[V][blog](<https://blog.getreu.net>)\f[R]'
.IP \[bu] 2
An inline image with relative local URL:
`\f[V]![Alt text](<images/my logo.png>)\f[R]'.
.IP \[bu] 2
A link to another Tp-Note document with a relative local link:
`\f[V][my doc](<../../notes/my doc.md>)\f[R]'
.IP \[bu] 2
The same as above, but using the short autolink syntax:
`\f[V]<http:../../notes/my%20doc.md>\f[R]'
.IP \[bu] 2
A link to another Tp-Note document with an absolute local link:
`\f[V][my doc](</home/kanban/docs/my note.md>)\f[R]' The base for
absolute local links is the first parent directory containing the marker
file `\f[V].tpnote.toml\f[R]'.
If absent, absolute local links refer to the root directory
`\f[V]/\f[R]'.
.IP \[bu] 2
A shorthand link to another Tp-Note document.
Instead of writing out the full file name, only the first characters of
the note\[cq]s sort-tag `\f[V]20230508\f[R]' are given, e.g.\ the link
`\f[V][my doc](<docs/20230508>)\f[R]' points to the file
`\f[V]./docs/20230508-my note.md\f[R]'.
Alternatively, the shorthand link can be expressed as autolink as well:
`\f[V]<http:docs/20230508>\f[R]'.
If more than one document with the same sort-tag exist, the viewer
displays the first in alphabetical order.
To set up a different order, you can extend the sort-tag until it
becomes unique, e.g.\ rename the example document to
`\f[V]./docs/20230508-1-my note.md\f[R]' to obtain the unique sort-tag
`\f[V]20230508-1\f[R]'.
.PP
Although Tp-Note\[cq]s built in viewer follows absolute and relative
URLs, usually the latter are preferred.
They make moving documents easier, as relative links do not break when
the source and the destination documents are moved together.
.PP
Tp-Note\[cq]s exporter function `\f[V]--export\f[R]' converts a given
Tp-Note file into HTML and adds `\f[V].html\f[R]' to the output
filename.
Links in the documents content to other Tp-Note files are hereby
rewritten by appending `\f[V].html\f[R]' to their URLs.
This way you can convert groups of documents to HTML and later jump from
document to document in your web browser.
The option `\f[V]--export-link-rewriting\f[R]' allows you to fine-tune
how local links are written out.
Valid values are: `\f[V]off\f[R]', `\f[V]short\f[R]' and
`\f[V]long\f[R]'.
.PP
In order to achieve this, the user must respect the following convention
concerning absolute paths in local links in Tp-Note documents: When a
document contains a local link with an absolute path, the base of this
path is considered to be the the directory where the marker file
`\f[V].tpnoteroot\f[R]' resides (or `\f[V]/\f[R]' in non exists).
The option `\f[V]--export-link- rewriting\f[R]' decides how local links
in the Tp-Note document are converted when the HTML is generated.
If its value is `\f[V]short\f[R]', then local links with relative paths
are converted to absolute paths.
The base of the resulting path is where the `\f[V].tpnoteroot\f[R]' file
resides (or \f[V]/\f[R] if none exists).
Consider the following example
`\f[V]--export-link-rewriting=short\f[R]':
.IP \[bu] 2
The Tp-Note file `\f[V]/my/docs/car/bill.md\f[R]' contains
.IP \[bu] 2
a local link with an absolute path: `\f[V]/car/scan.jpg\f[R]',
.IP \[bu] 2
and another link with a relative path: `\f[V]./photo.jpg\f[R]'.
.IP \[bu] 2
The document root marker is: `\f[V]/my/docs/.tpnoteroot\f[R]'.
.PP
The images in the resulting HTML will appear as
.IP \[bu] 2
`\f[V]/car/scan.jpg\f[R]'.
.IP \[bu] 2
`\f[V]/car/photo.jpg\f[R]'.
.PP
For `\f[V]--export-link-rewriting=short\f[R]', in addition to the above,
all absolute paths in local links are rebased to `\f[V]/\f[R]'\[cq].
Consider the following example:
.IP \[bu] 2
The Tp-Note file `\f[V]/my/docs/car/bill.md\f[R]' contains
.IP \[bu] 2
a link with an absolute path: `\f[V]/car/scan.jpg\f[R]',
.IP \[bu] 2
and another link with a relative path: `\f[V]./photo.jpg\f[R]'.
.IP \[bu] 2
The document root marker is: `\f[V]/my/docs/.tpnoteroot\f[R]'.
.PP
The images in the resulting HTML will appear as
.IP \[bu] 2
`\f[V]/my/docs/car/scan.jpg\f[R]'.
.IP \[bu] 2
`\f[V]/my/docs/car/photo.jpg\f[R]'.
.PP
So far, we have seen how Tp-Note\[cq]s viewer and HTML exporter converts
the \f[I]destination\f[R] of local links
`\f[V][text](destination)\f[R]'.
Concerning the link\[cq]s \f[I]text\f[R] property of local links, the
situation is simpler as the \f[I]text\f[R] property never changes.
However, there is one exception: when the text property contains an
autolink starting with `\f[V]tpnote:\f[R]' or `\f[V]http:\f[R]' only the
file stem is displayed.
For example, the autolink: `\f[V]<tpnote:dir/my file.md>.\f[R]' is
transformed into `\f[V][my file](<tpnote:dir/my file.md>)\f[R]' during
the HTML rendition process.
This explains why it appears as `\f[V]my file\f[R]' in the browser.
.SH METADATA FILENAME SYNCHRONIZATION
.PP
Consider the following Tp-Note file:
.IP
.nf
\f[C]
20151208-Make this world a better place--Suggestions.md
\f[R]
.fi
.PP
The filename has 4 parts:
.IP
.nf
\f[C]
{{ fm_sort_tag }}-{{ fm_title }}--{{ fm_subtitle }}.{{ fm_file_ext }}
\f[R]
.fi
.PP
A so-called \f[I]sort tag\f[R] is a numerical prefix at the beginning of
the filename.
It is used to order files and notes in the file system.
Besides numerical digits and whitespace, a \f[I]sort tag\f[R] can be any
combination of `\f[V]_\f[R]', `\f[V]-\f[R]', `\f[V]\f[R]',
`\f[V]\[rs]t\f[R]', `\f[V].\f[R]' and is usually used as
.IP \[bu] 2
\f[I]chronological sort tag\f[R]
.RS 2
.IP
.nf
\f[C]
  20140211-Reminder.doc
  20151208-Manual.pdf
  2015-12-08-Manual.pdf
\f[R]
.fi
.RE
.IP \[bu] 2
or, as a \f[I]sequence number sort tag\f[R].
.RS 2
.IP
.nf
\f[C]
  02-Invoices
  08-Tax documents
  09_02-Notes
  09.09-Notes
\f[R]
.fi
.RE
.PP
When Tp-Note creates a new note, it will automatically prepend a
\f[I]chronological sort tag\f[R] of today.
The `\f[V]{{ fm_title }}\f[R]' part is usually derived from the parent
directory name omitting its own \f[I]sort tag\f[R].
.PP
Technical note: a sort tag is identified with the following regular
expression in SED syntax:
`\f[V]s/\[rs]([0-9_- .\[rs]t]\[rs])*-\[aq]?.*/\[rs]1/\f[R]'.
The expression can be customized as follows: *
`\f[V][0-9_- .\[rs]t]\f[R]' with `\f[V]filename.sort_tag_chars\f[R]', *
`\f[V]-\f[R]' with `\f[V]filename.sort_tag_separator\f[R]' and *
`\f[V]\[aq]\f[R]' with `\f[V]filename.sort_tag_extra_separator\f[R]'.
.PP
A note\[cq]s filename is in sync with its metadata, when the following
is true (slightly simplified, see the configuration file for the
complete definition):
.RS
.PP
filename on disk without \f[I]sort tag\f[R] ==
`\f[V]{{ fm_title }}--{{ fm_subtitle }}.md\f[R]'
.RE
.PP
[1]
.PP
Consider the following document with the filename:
.IP
.nf
\f[C]
20211031-My file.md
\f[R]
.fi
.PP
and the content:
.IP
.nf
\f[C]
---
title:      1. The Beginning
subtitle:   Note
author:     Getreu
date:       2021-10-31
lang:       en-GB

remainder:  false
---
\f[R]
.fi
.PP
As `\f[V]My file.md\f[R]' is not equal to
`\f[V]1. The Beginning--Note.md\f[R]', Tp-Note will rename the file to
`\f[V]20211031-1. The Beginning--Note.md\f[R]'.
If the filename had been `\f[V]05_02-My file.md\f[R]', it would rename
it to `\f[V]05_02-1. The Beginning--Note.md\f[R]'.
.PP
Note: When the YAML front-matter does not contain the optional
`\f[V]sort_tag\f[R]' variable, Tp-Note will never change a sort tag.
Nevertheless, it might change the rest of the filename!
.PP
The reason why by default Tp-Note does not change sort tags is, that
they define their order in the file listing.
In general this order is independent of the notes content.
The simplest way to organize the sort tags of your files is by renaming
them directly in your file system.
Nevertheless, in some cases you might want to have full control over the
whole filename through the note\[cq]s YAML front-matter.
For example, if \[em] for some reason \[em] you have changed the
document\[cq]s date in the front-matter and you want to change the
chronological sort tag in one go.
In order to overwrite the note\[cq]s sort tag on disk, you can add a
`\f[V]sort_tag\f[R]' string-variable to its front-matter:
.IP
.nf
\f[C]
---
title:      1. The Beginning
date:       2021-10-31

sort_tag:   \[aq]20211101\[aq]
---
\f[R]
.fi
.PP
Note, the above sort-tag value - here a number - must be enclosed with
quotes in order label it as string type.
When Tp-Note synchronizes the note\[cq]s metadata with its filename, it
will also change the sort tag from `\f[V]20211031\f[R]' to
`\f[V]20211101\f[R]'.
The resulting filename becomes
`\f[V]20211101-1. The Beginning--Note.md\f[R]'.
.PP
The `\f[V]sort_tag\f[R]' variable also becomes handy, when you want to
create one single note without any sort tag:
.IP
.nf
\f[C]
---
title:      1. The Beginning

sort_tag:   \[aq]\[aq]
---
\f[R]
.fi
.PP
In the same way, how it is possible to pin the sort tag of the note from
within the note\[cq]s metadata, you can also change the file extension
by adding the optional `\f[V]file_ext\f[R]' variable into the note\[cq]s
front-matter:
.IP
.nf
\f[C]
---
title:      1. The Beginning

file_ext:   rst
---
\f[R]
.fi
.PP
This will change the file extension from `\f[V].md\f[R]' to
`\f[V].rst\f[R].
The resulting filename
becomes'\f[V]20211101-1. The Beginning--Note.rst\f[R]\[cq].
.PP
Important: `\f[V]rst\f[R]' must be one of the registered file extensions
listed in the `\f[V]filename.extensions\f[R]' variable in Tp-Note\[cq]s
configuration file.
If needed you can add more extensions there.
If the new filename extension is not listed in one of these variables,
Tp-Note will not be able to recognize the note file as such and will not
open it in the external text editor and viewer.
.PP
Note: When a `\f[V]sort_tag\f[R]' variable is defined in the note\[cq]s
YAML header, you should not change the sort tag string in the note\[cq]s
file name manually by renaming the file, as your change will be
overwritten next time you open the note with Tp-Note.
However, you can switch back to Tp-Note\[cq]s default behaviour any time
by deleting the `\f[V]sort_tag\f[R]' line in the note\[cq]s metadata.
The same applies to the `\f[V]file_ext\f[R]' variable.
.PP
The metadata filename synchronization feature can be disabled
permanently by setting the configuration file variable
`\f[V]arg_default.no_filename_sync = true\f[R]'.
To disable this feature for one time only, invoke Tp-Note with
`\f[V]--no-filename-sync\f[R]'.
To exclude a particular note from filename synchronization, add the YAML
header field `\f[V]filename_sync: false\f[R]'.
.IP
.nf
\f[C]
---
title:         1. The Beginning   

filename_sync: false
---
\f[R]
.fi
.PP
Note, that in the above described examples, the information flow always
goes from the YAML note header towards the note\[cq]s filename.
However, when Tp-Note opens a text file without a YAML header, a new
header is added automatically.
In this case the information flow goes from the filename towards the
header, namely in the opposite direction.
Once the new header is prepended to the text file, a regular filename
synchronization - as described above - is triggered and executed as
described above.
.PP
Technically, all rules and logic of how the synchronization is executed,
are encoded in customizable so-called filename templates (cf.\ section
\f[I]Templates\f[R]).
.SH CUSTOMIZATION
.PP
Tp-Note\[cq]s configuration file resides typically in
`\f[V]\[ti]/.config/tpnote/tpnote.toml\f[R]' under Unix or in
`\f[V]C:\[rs]Users\[rs]<LOGIN>\[rs]AppData\[rs]Roaming\[rs]tpnote\[rs]config\[rs]tpnote.toml>\f[R]'
under Windows.
`\f[V]tpnote --version\f[R]' prints the current configuration file path.
.PP
Besides the standard configuration path, Tp-Note searches for its
configuration data at the following locations:
.IP "1." 3
If the command line parameter `\f[V]--config <path>\f[R]' is given,
`\f[V]<path>\f[R]' indicates the location of the configuration file.
.IP "2." 3
If the environment variable `\f[V]TPNOTE_CONFIG=\[dq]<path>\[dq]\f[R]'
is set, `\f[V]<path>\f[R]' indicates the location of the configuration
file.
.IP "3." 3
At startup all parent directories of the note file path are searched for
a file named `\f[V].tpnote.toml\f[R]'.
If found, the document root moves from `\f[V]/\f[R]' the found location.
If present and its content is not empty, Tp-Note interprets the
file\[cq]s content as configuration file.
Continue otherwise.
.IP "4." 3
Tp-Note tries to find its configuration data at the operating
system\[cq]s standard location indicated here above.
.PP
When Tp-Note starts, it first tries to find its configuration file.
Once found, the syntax of the configuration is checked.
If not correct, the configuration file is renamed and replaced by a file
with correct syntax and default values.
If Tp-Note fails to find a configuration file at any of the above
locations, it writes a default configuration file at the expected
standard location.
.PP
Tp-Note is best customized by starting it once, and then modifying its
default configuration.
.IP
.nf
\f[C]
tpnote -V -b
\f[R]
.fi
.PP
To create a configuration file in the current directory invoke Tp-Note
with `\f[V]-c\f[R]'.
.IP
.nf
\f[C]
tpnote -V -b -c .tpnote.toml
\f[R]
.fi
.SS Register your own text editor
.PP
There are two ways to modify the default file editor, Tp-Note launches
when it starts: either you can modify the configuration file variables
`\f[V]app_args.*.editor\f[R]' and `\f[V]app_args.*.editor_console\f[R]',
or alternatively, you can set the `\f[V]TPNOTE_EDITOR\f[R]' environment
variable (cf.\ examples in the chapter \f[I]ENVIRONMENT_VARIABLES\f[R]
below).
.PP
The configuration file variables `\f[V]app_args.unix.editor\f[R]' and
`\f[V]app_args.unix.editor_console\f[R]' define lists of external text
editors to be launched for editing.
The lists contain by default well-known text editor names and their
command line arguments for Unix like operating systems.
For other systems consult: `\f[V]app_args.windows.editor\f[R]',
`\f[V]app_args.windows.editor_console\f[R]',
`\f[V]app_args.macos.editor\f[R]' and
`\f[V]app_args.macos.editor_console\f[R]'.
Tp-Note tries to launch every text editor in
`\f[V]app_args.*.editor\f[R]' from the beginning of the list until it
finds an installed text editor.
When Tp-Note is started on a Linux console, the list
`\f[V]app_args.*.editor_console\f[R]' is used instead.
Here you can register text editors that do not require a graphical
environment, e.g.\ `\f[V]vim\f[R]' or `\f[V]nano\f[R]'.
In order to use your own text editor, just place it at the top of the
list.
To debug your changes invoke Tp-Note with
`\f[V]tpnote --debug debug --popup --edit\f[R]'.
.PP
The following example showcases the configuration for the \f[I]Kate\f[R]
file editor.
The entry `\f[V]kate\f[R]' launches the binary, while the command line
parameter `\f[V]--block\f[R]' guarantees, that the launched process
blocks until the user closes the editor.
Tp-Note detects the end of the process, checks if the title of the note
files has changed in its YAML header and renames the note file if
necessary.
.IP
.nf
\f[C]
unix.editor = [
  [
    \[aq]kate\[aq],
    \[aq]--block\[aq]
  ]
]
\f[R]
.fi
.PP
The equivalent configuration with environment variable:
.IP
.nf
\f[C]
TPNOTE_EDITOR=\[dq]kate --block\[dq] tpnote
\f[R]
.fi
.PP
All items in the above list are subject to limited template expansion
allowing to insert the value of environment variables.
Consider the following example:
.IP
.nf
\f[C]
windows.editor = [
    [
    \[aq]{{ get_env(name=\[dq]LOCALAPPDATA\[dq]) }}\[rs]Programs\[rs]Microsoft VS Code\[rs]Code.exe\[aq],
    \[dq]--new-window\[dq], \[dq]--wait\[dq],
    ]
]
\f[R]
.fi
.PP
When the configuration file is loaded, the above expression
`\f[V]{{ get_env(name=\[dq]LOCALAPPDATA\[dq]) }}\f[R]' expands under
Windows for a user with the username `\f[V]Joe\f[R]' to
`\f[V]C:\[rs]User\[rs]Joe\[rs]AppData\[rs]Local\f[R]' resulting in:
.IP
.nf
\f[C]
windows.editor = [
    [
    \[aq]C:\[rs]User\[rs]Joe\[rs]AppData\[rs]Local\[rs]Programs\[rs]Microsoft VS Code\[rs]Code.exe\[aq],
    \[dq]--new-window\[dq], \[dq]--wait\[dq],
    ]
]
\f[R]
.fi
.PP
In general, when you configure Tp-Note to work with your text editor,
make sure, that your text editor does not fork!
You can check this by launching the text editor from the command line:
if the command prompt returns immediately, then the file editor forks
the process.
On the other hand everything is OK, when the command prompt only
reappears at the moment the text editor is closed.
Many text editors provide an option to restrain from forking: for
example the \f[I]VScode\f[R] file editor can be launched with the
`\f[V]--wait\f[R]' option, \f[I]Vim\f[R] with `\f[V]--nofork\f[R]' or
\f[I]Kate\f[R] with `\f[V]--block\f[R]'.
.PP
However, Tp-Note also works with forking text editors.
Although this should be avoided, there is a possible workaround.
Observe the following example:
.IP
.nf
\f[C]
$ TPNOTE_EDITOR=\[dq]kate\[dq] tpnote
/home/getreu/20230714-getreu--Note.md
$ 
\f[R]
.fi
.PP
In the above example Tp-Note launches the `\f[V]kate\f[R]' editor in a
forking manner as the command line flag `\f[V]--block\f[R]' is missing.
Internally the editor process launching returns immediately, leaving
Tp-Note without any means to detect when exactly the user closes the
editor.
Hence, Tp-Note is not able to check if the user has changed the
note\[cq]s header and no filename synchronization can occur afterwards.
.PP
As a workaround, you can manually trigger the filename synchronization
after editing with `\f[V]tpnote --batch \[dq]$FILE\[dq]\f[R]':
.IP
.nf
\f[C]
FILE=$(tpnote --batch) # Create the new note.
tpnote --view \[dq]$FILE\[dq]& # Launch Tp-Note\[aq]s viewer.
kate \[dq]$FILE\[dq]           # Note, the prompt returns immediatly as the editor forks.
                       # After closing the editor when editing is done...
tpnote --batch \[dq]$FILE\[dq] # Synchronize the note\[aq]s filename again.
\f[R]
.fi
.PP
Whereby `\f[V]FILE=$(tpnote --batch)\f[R]' creates the note file,
`\f[V]kate \[dq]$FILE\[dq]\f[R]' opens the text editor and
`\f[V]tpnote --batch \[dq]$FILE\[dq]\f[R]' synchronizes the filename
after editing.
.PP
NB: Try to avoid forking at all cost.
As mentioned above, most text editors have a command line flag to
prevent the process from forking:
.IP
.nf
\f[C]
TPNOTE_EDITOR=\[dq]kate --block\[dq] tpnote
\f[R]
.fi
.PP
\f[B]Register a Flatpak Markdown editor\f[R]
.PP
Flathub for Linux (https://www.flathub.org/home) is a cross-platform
application repository that works well with Tp-Note.
To showcase an example, we will add a Tp-Note launcher for the \f[I]Mark
Text\f[R] Markdown text editor available as Flatpak
package (https://www.flathub.org/apps/details/com.github.marktext.marktext).
Before installing, make sure that you have set up
Flatpack (https://flatpak.org/setup/) correctly.
Then install the application with:
.IP
.nf
\f[C]
sudo flatpak install flathub com.github.marktext.marktext
\f[R]
.fi
.PP
To test, run \f[I]Mark Text\f[R] from the command line:
.IP
.nf
\f[C]
flatpak run com.github.marktext.marktext
\f[R]
.fi
.PP
Then open Tp-Note\[cq]s configuration file \f[V]tpnote.toml\f[R] and
search for the `\f[V]app_args.unix.editor\f[R]' variable, quoted
shortened below:
.IP
.nf
\f[C]
[app_args]
unix.editor = [
    [
    \[aq]code\[aq],
    \[aq]-w\[aq],
    \[aq]-n\[aq],
],
#...
]
\f[R]
.fi
.PP
The structure of this variable is a list of lists.
Every item in the outer list corresponds to one entire command line
launching a different text editor, here \f[I]VSCode\f[R].
When launching, Tp-Note searches through this list until it finds an
installed text editor on the system.
.PP
In the next example, we register the \f[I]Mark Text\f[R] editor at the
first place in this list, by inserting
`\f[V][\[aq]flatpak\[aq], \[aq]run\[aq], \[aq]com.github.marktext.marktext\[aq]]\f[R]':
.IP
.nf
\f[C]
[app_args]
unix.editor = [
    [
    \[aq]flatpak\[aq],
    \[aq]run\[aq],
    \[aq]com.github.marktext.marktext\[aq],
],
    [
    \[aq]code\[aq],
    \[aq]-w\[aq],
    \[aq]-n\[aq],
],
#...
]
\f[R]
.fi
.PP
Save the modified configuration file.
Next time you launch Tp-Note, the \f[I]Mark Text\f[R]-editor will open.
.PP
\f[B]Register a console text editor running in a terminal emulator\f[R]
.PP
In this setup Tp-Note launches the terminal emulator which is configured
to launch the text editor as child process.
Neither process should fork when they start (see above).
.PP
Here, some examples you can adjust to your needs and taste:
.IP \[bu] 2
\f[I]Neovim\f[R] in \f[I]Xfce4-Terminal\f[R]:
.RS 2
.IP
.nf
\f[C]
[app_args]
unix.editor = [
  [
    \[aq]xfce4-terminal\[aq],
    \[aq]--disable-server\[aq],
    \[aq]-x\[aq],
    \[aq]nvim\[aq],
    \[aq]+colorscheme pablo\[aq],
    \[aq]+set syntax=markdown\[aq],
  ],
]
\f[R]
.fi
.RE
.IP \[bu] 2
\f[I]Neovim\f[R] in \f[I]LXTerminal\f[R]:
.RS 2
.IP
.nf
\f[C]
[app_args]
unix.editor = [
  [
    \[aq]lxterminal\[aq],
    \[aq]--no-remote\[aq],
    \[aq]-e\[aq],
    \[aq]nvim\[aq],
    \[aq]+colorscheme pablo\[aq],
    \[aq]+set syntax=markdown\[aq],
  ],
]
\f[R]
.fi
.RE
.IP \[bu] 2
\f[I]Neovim\f[R] in \f[I]Xterm\f[R]:
.RS 2
.IP
.nf
\f[C]
[app_args]
unix.editor = [
  [
    \[aq]xterm\[aq],
    \[aq]-fa\[aq],
    \[aq]DejaVu Sans Mono\[aq],
    \[aq]-fs\[aq],
    \[aq]12\[aq],
    \[aq]-e\[aq],
    \[aq]nvim\[aq],
    \[aq]+colorscheme pablo\[aq],
    \[aq]+set syntax=markdown\[aq],
  ],
]
\f[R]
.fi
.RE
.IP \[bu] 2
\f[I]Neovim\f[R] in \f[I]Alacritty\f[R]:
.RS 2
.IP
.nf
\f[C]
[app_args]
unix.editor = [
  [
    \[aq]alacritty\[aq],
    \[aq]-e\[aq],
    \[aq]nvim\[aq],
    \[aq]+colorscheme pablo\[aq],
    \[aq]+set syntax=markdown\[aq],
  ],
]
\f[R]
.fi
.RE
.IP \[bu] 2
\f[I]Helix-editor\f[R] in \f[I]XFCE4-Terminal\f[R]:
.RS 2
.IP
.nf
\f[C]
[app_args]
unix.editor = [
  [
    \[aq]xfce4-terminal\[aq],
    \[aq]--disable-server\[aq],
    \[aq]-x\[aq],
    \[aq]hx\[aq],
  ],
]
\f[R]
.fi
.RE
.SS Change the file extension for new note files
.PP
Tp-Note identifies the note\[cq]s markup language by its file extension
and renders the content accordingly (see `\f[V]filename.extensions\f[R]'
variable).
For example: the variable `\f[V]filename.extensions\f[R]' lists some
extensions, that are regarded as Markdown files:
.IP
.nf
\f[C]
[filename]
extensions = [
  [ \[dq]txt\[dq], \[dq]Markdown\[dq] ],
  [ \[dq]md\[dq], \[dq]Markdown\[dq] ],
  [ \[dq]markdown\[dq], \[dq]Markdown\[dq] ],
  [ \[dq]markdn\[dq], \[dq]Markdown\[dq] ],
  [ \[dq]mdown\[dq], \[dq]Markdown\[dq] ],
  [ \[dq]mdtxt\[dq], \[dq]Markdown\[dq] ],
]
\f[R]
.fi
.PP
The default file extension for new note files is defined as:
.IP
.nf
\f[C]
[filename]
extension_default = \[aq]md\[aq]
\f[R]
.fi
.PP
If you prefer rather the file extension `\f[V].markdown\f[R]' for new
notes, change this to:
.IP
.nf
\f[C]
[filename]
extension_default = \[aq]markdown\[aq]
\f[R]
.fi
.PP
This modification does not change how the note file\[cq]s content is
interpreted - in this case as Markdown - because both file extensions
`\f[V].md\f[R]' and `\f[V].markdown\f[R]' are rendered as
`\f[V]Markdown\f[R]' according to `\f[V]filename.extensions\f[R]'.
.SS Configure the natural language detection algorithm
.PP
When creating a new header for a new or an existing note file, a
linguistic language detection algorithm tries to determine in what
natural language the note file is authored.
Depending on the context, the algorithm processes as input: the header
field `\f[V]title:\f[R]' or the first sentence of the text body.
The natural language detection algorithm is implemented as a template
filter named `\f[V]get_lang\f[R]', which is used in various Tera content
templates `\f[V]tmpl.*_content\f[R]' in Tp-Note\[cq]s configuration
file.
The filter `\f[V]get_lang\f[R]' is parametrized by the configuration
variable `\f[V]tmpl.filter_get_lang\f[R]' containing a list of ISO 639-1
encoded languages, the algorithm considers as potential detection
candidates, e.g.:
.IP
.nf
\f[C]
[tmpl]
filter_get_lang = [
    \[aq]en\[aq],
    \[aq]fr\[aq],
    \[aq]de\[aq],
    \[aq]et\[aq]
]
\f[R]
.fi
.PP
As natural language detection is CPU intensive, it is advised to limit
the number of detection candidates to 5 or 6, depending on how fast your
computer is.
The more language candidates you include, the longer the note file
creation takes time.
As a rule of thumb, with all languages enabled the creation of new notes
can take up to 4 seconds on my computer.
Nevertheless, it is possible to enable all available detection
candidates with the pseudo language code `\f[V]+all\f[R]' which stands
for \[lq]add all languages\[rq]:
.IP
.nf
\f[C]
[tmpl]
filter_get_lang = [
    \[aq]+all\[aq],
]
\f[R]
.fi
.PP
Once the language is detected with the filter `\f[V]get_lang\f[R]', it
passes another filter called `\f[V]map_lang\f[R]'.
This filter maps the result of `\f[V]get_lang\f[R]' - encoded as ISO
639-1 code - to an IETF language tag.
For example, `\f[V]en\f[R]' is replaced with `\f[V]en-US\f[R]' or
`\f[V]de\f[R]' with `\f[V]de-DE\f[R]'.
This additional filtering is useful, because the detection algorithm can
not figure out the region code (e.g.\ \f[V]-US\f[R] or \f[V]-DE\f[R]) by
itself.
Instead, the region code is appended in a separate processing step.
Spell checker or grammar checker like [LTeX] rely on this region
information, to work properly.
.PP
The corresponding configuration looks like this:
.IP
.nf
\f[C]
[tmpl]
filter_map_lang = [
    [
    \[aq]en\[aq],
    \[aq]en-US\[aq],
],
    [
    \[aq]de\[aq],
    \[aq]de-DE\[aq],
],
]
\f[R]
.fi
.PP
When the user\[cq]s region setting - as reported from the operating
system\[cq]s locale setting - does not exist in above list, it is
automatically appended as additional internal mapping.
When the filter \f[V]map_lang\f[R] encounters a language code for which
no mapping is configured, the input language code is forwarded as it is
without modification, e.g.\ the input \f[V]fr\f[R] results in the output
\f[V]fr\f[R].
Subsequent entries that differ only in the region subtag, e.g.
`\f[V][\[aq]en\[aq], \[aq]en- GB\[aq]], [\[aq]en\[aq], \[aq]en-US\[aq]]\f[R]'
are ignored.
.PP
Note, that the environment variable `\f[V]TPNOTE_LANG_DETECTION\f[R]' -
if set - takes precedence over the `\f[V]tmpl.filter_get_lang\f[R]' and
`\f[V]tmpl.filter_map_lang\f[R]' settings.
This allows configuring the language detection feature system-wide
without touching Tp-Note\[cq]s configuration file.
The following example achieves the equivalent result to the
configuration hereinabove:
.IP
.nf
\f[C]
TPNOTE_LANG_DETECTION=\[dq]en-US, fr, de-DE, et\[dq] tpnote
\f[R]
.fi
.PP
If you want to enable all language detection candidates, add the pseudo
tag `\f[V]+all\f[R]' somewhere to the list:
.IP
.nf
\f[C]
TPNOTE_LANG_DETECTION=\[dq]en-US, de-DE, +all\[dq] tpnote
\f[R]
.fi
.PP
In the above example the IETF language tags `\f[V]en-US\f[R]' and
`\f[V]de-DE\f[R]' are retained in order to configure the region codes
`\f[V]US\f[R]' and `\f[V]DE\f[R]' used by the `\f[V]map_lang\f[R]'
template filter.
.PP
For debugging observe the value of `\f[V]SETTINGS\f[R]' in the debug log
with:
.IP
.nf
\f[C]
tpnote -d trace -b
\f[R]
.fi
.PP
If wished for, you can disable Tp-Note\[cq]s language detection feature,
by deleting all entries in the `\f[V]tmpl.filter_get_lang\f[R]'
variable:
.IP
.nf
\f[C]
[tmpl]
filter_get_lang = []
\f[R]
.fi
.PP
Like above, you can achieve the same with:
.IP
.nf
\f[C]
TPNOTE_LANG_DETECTION=\[dq]\[dq] tpnote
\f[R]
.fi
.SS Change the default markup language
.PP
Tp-Note\[cq]s core functionality, the management of note file headers
and filenames, is markup language agnostic.
However, there is one content template
`\f[V]tmpl.annotate_file_content\f[R]' that generates a hyperlink.
The hyperlink syntax varies depending on the markup language.
Hence, you should not forget to modify the
`\f[V]tmpl.annotate_file_content\f[R]' content template, when you change
the default markup language defined in
`\f[V]filename.extension_default\f[R]'.
.SS Change default markup language to ReStructuredText
.PP
Tp-Note\[cq]s core function is a template system and as such it depends
very little on the used markup language.
The default templates are designed in a way that they contain almost no
markup specific code.
There is one little exception though.
The following configuration variables affect the way new notes are
created:
.IP "1." 3
Change the default file extension for new notes from:
.RS 4
.IP
.nf
\f[C]
[filename]
extension_default=\[aq]md\[aq]
\f[R]
.fi
.PP
to:
.IP
.nf
\f[C]
[filename]
extension_default=\[aq]rst\[aq]
\f[R]
.fi
.PP
Alternatively, the above can be achieved by setting the environment
variable `\f[V]TPNOTE_EXTENSION_DEFAULT\f[R]':
.IP
.nf
\f[C]
TPNOTE_EXTENSION_DEFAULT=\[dq]rst\[dq] tpnote
\f[R]
.fi
.RE
.IP "2." 3
Replace the following line in the template
`\f[V]tmpl.annotate_file_content\f[R]' that defines a hyperlink in
Markdown format:
.RS 4
.IP
.nf
\f[C]
[{{ path | file_name }}](<{{ path | file_name }}>)
\f[R]
.fi
.PP
with the following line encoded in ReStructuredText syntax:
.IP
.nf
\f[C]
\[ga]<{{ path | file_name }}>\[ga]_
\f[R]
.fi
.RE
.PP
As a result, all future notes are created as `\f[V]*.rst\f[R]' files.
.SS Change the markup language for one specific note only
.PP
You can change the Markup language of a specific note by adding the
variable `\f[V]file_ext:\f[R]' to its YAML header.
For example, for ReStructuredText add:
.IP
.nf
\f[C]
---
title:    some note
file_ext: rst
---
\f[R]
.fi
.PP
When Tp-Note triggers the next filename synchronization, the filename
extension of the note file will change to `\f[V].rst\f[R]'.
The above modification applies to the current note only.
.SS Change the sort tag character set
.PP
\f[I]Sort-tags\f[R] for new notes are generated with the
`\f[V]tmpl.*_filename\f[R]' templates.
Before changing the sort-tag generation scheme in these templates, make
sure to enable the right set of potential sort-tag characters.
.PP
By default, the digits `\f[V]0\f[R]'-`\f[V]9\f[R]', the characters
`\f[V]_\f[R]', `\f[V]-\f[R]', \f[I]space\f[R], `\f[V]\[rs]t\f[R]' and
`\f[V].\f[R]' are recognized as being part of a \f[I]sort tag\f[R] when
they appear at the beginning of a filename.
This set of characters can be modified with the
`\f[V]filename.sort_tag_chars\f[R]' configuration variable.
If defined, the `\f[V]filename.sort_tag_separator\f[R]' (by default
`\f[V]-\f[R]') marks the end of a sort tag without being part of it.
In addition, one special character
`\f[V]filename.sort_tag_extra_separator\f[R]' (by default
`\f[V]\[aq]\f[R]') might be inserted by the filename template directly
after the `\f[V]-\f[R]' to avoid ambiguity.
.SS Customize the filename synchronization scheme
.PP
The filename synchronization scheme is fully customizable through
\f[I]Tp-Note\[cq]s filename templates\f[R].
To design such a custom scheme, start to set up your synchronization
rules in the `\f[V]tmpl.sync_filename\f[R]' template.
Then adjust all `\f[V]tmpl.*_filename\f[R]' templates to comply with
these rules.
In order to verify your design, check that the following holds for any
sequential application of one `\f[V]tmpl.*_filename\f[R]' template
followed directly by the `\f[V]tmpl.sync_filename\f[R]' template: The
latter should never change the filename initially set up by any
`\f[V]tmpl.*_filename\f[R]' template.
.PP
Secondly, make sure that in filename templates
`\f[V]tmpl.*_filename\f[R]', sort-tags
`\f[V]{{ path | file_sort_tag }}\f[R]' are never inserted directly.
Instead, prepend the \f[I]sort_tag\f[R] with
`\f[V]prepend(with_sort_tag=path|file_sort_tag)\f[R]' to the following
expression, e.g.:
.IP
.nf
\f[C]
{{ fm_title | sanit | prepend(with_sort_tag=path|file_sort_tag) }}
\f[R]
.fi
.PP
The filter `\f[V]prepend(with_sort_tag=<...>)\f[R]' decides whether to
insert the `\f[V]sort_tag_separator=\[dq]-\[dq]\f[R]' and/or the
`\f[V]sort_tag_extra_separator=\[dq]\[aq]\[dq]\f[R]' characters.
These heuristics enable Tp-Note to identify unequivocally sort-tags in
filenames, which avoids potential cyclic filename change.
Or, in other words: the `\f[V]tmpl.sync_filname\f[R]' template must
always give the same result, even after repeated application.
.PP
To debug your `\f[V]tmpl.sync_filename\f[R]' template, create a test
note file `\f[V]test.md\f[R]' and invoke Tp-Note with
`\f[V]--debug trace\f[R]' and `\f[V]--batch\f[R]':
.IP
.nf
\f[C]
tpnote --batch --debug trace test.md
\f[R]
.fi
.SS Store new note files by default in a subdirectory
.PP
When you are annotating an existing file on disk, the new note file is
placed in the same directory by default.
To configure Tp-Note to store the new note file in a subdirectory,
let\[cq]s say `\f[V]Notes/\f[R]', instead, you need to modify the
templates `\f[V]tmpl.annotate_file_filename\f[R]' and
`\f[V]tmpl.annotate_file_content\f[R]':
.PP
Replace in `\f[V]tmpl.annotate_file_filename\f[R]' the string:
.IP
.nf
\f[C]
{{ path | file_sort_tag }}
\f[R]
.fi
.PP
with:
.IP
.nf
\f[C]
Notes/{{ path | file_sort_tag }}
\f[R]
.fi
.PP
and in `\f[V]tmpl.annotate_file_content\f[R]':
.IP
.nf
\f[C]
[{{ path | filename }}](<{{ path | filename }}>)
\f[R]
.fi
.PP
with:
.IP
.nf
\f[C]
[{{ path | filename }}](<../{{ path | filename }}>)
\f[R]
.fi
.PP
Unlike early versions of Tp-Note, relative links can now start with
\f[V]../\f[R].
This became possible with the introduction of link rewriting in the HTML
rendition code of the viewer feature.
Relative links are now always converted into absolute links before being
sent to the browser.
See subsection \f[I]Links to resources and other documents\f[R] for more
details about link rewriting.
.SS Customize the built-in note viewer
.PP
\f[B]Delay the launch of the web browser\f[R]
.PP
By default, Tp-Note launches two external programs: some text editor and
a web browser.
If wished for, the configuration variable
`\f[V]viewer.startup_delay\f[R]' allows delaying the launch of the web
browser some milliseconds.
This way the web browser window will always appear on top of the editor
window.
A negative value delays the start of the text editor instead.
.PP
\f[B]Change the way how note files are rendered for viewing\f[R]
.PP
Besides its core function, Tp-Note comes with several built-in markup
renderer and viewer, allowing to work with different markup languages at
the same time.
The configuration file variable `\f[V]filename.extension\f[R]' determine
which markup renderer is used for which note file extension.
Depending on the markup language, this feature is more or less advanced
and complete: \f[I]Markdown\f[R] (cf.\ `\f[V]Markdown\f[R]') is best
supported and feature complete: It complies with the \f[I]Common
Mark\f[R] specification.
The \f[I]ReStructuredText\f[R] renderer
(cf.\ `\f[V]Restructuredtext\f[R]') is quite new and still in
experimental state.
For all other supported markup languages Tp-Note provides a built-in
markup source text viewer (cf.\ `\f[V]PlainText\f[R]') that shows the
note as typed (without markup), but renders all hyperlinks to make them
clickable.
In case none of the above rendition engines suit you, it is possible to
disable the viewer feature selectively for some particular note file
extensions: just associate these extensions with the
`\f[V]PlainTextNoViewer\f[R]' renderer.
If you wish to disable the viewer feature overall, set the variable
`\f[V]arg_default.edit = true\f[R]'.
.PP
\f[B]Change the HTML rendition template\f[R]
.PP
After the markup rendition process, Tp-Note\[cq]s built-in viewer
generates its final HTML rendition through the customizable HTML
templates `\f[V]tmpl_html.viewer\f[R]',
`\f[V]tmpl_html.viewer_error\f[R]' and `\f[V]tmpl_html.exporter\f[R]'.
Unlike content templates and filename templates, all HTML templates
escape HTML critical characters in variables by default.
To disable escaping for a specific variable, add the `\f[V]safe\f[R]'
filter in last position of the filter chain.
Please note, that in general, the `\f[V]safe\f[R]' filter is only
recommended directly after the `\f[V]to_html\f[R]' and the
`\f[V]markup_to_html\f[R]' filters, because these handle critical input
by themselves.
The following code example, inspired by the `\f[V]tmpl_html.viewer\f[R]'
template, illustrates the available variables:
.IP
.nf
\f[C]
[tmpl_html]
viewer = \[aq]\[aq]\[aq]
{%- set ext = fm_file_ext | default(value=extension_default ) -%}
<!DOCTYPE html>
<html lang=\[dq]{{ fm_lang | default(value=\[aq]en\[aq]) }}\[dq]>
<head>
<meta charset=\[dq]utf-8\[dq]>
<title>{{ fm_title }}</title>
<link rel=\[dq]stylesheet\[dq] href=\[dq]{{ viewer_doc_css_path }}\[dq]>
<link rel=\[dq]stylesheet\[dq] href=\[dq]{{ viewer_highlighting_css_path }}\[dq]>
  </head>
  <body>
  <pre class=\[dq]doc-header\[dq]>{{ doc_fm_text }}</pre>
  <hr>
  <div class=\[dq]doc-body\[dq]>
    {{ doc_body_text | markup_to_html(extension=ext) | safe }}
  </div>
  <script>{{ viewer_doc_js | safe }}</script>
</body>
</html>
\[aq]\[aq]\[aq]
\f[R]
.fi
.PP
Specifically:
.IP \[bu] 2
`\f[V]{{ fm_* }}\f[R]' are the deserialized header variables.
All content template variables and filters are available.
See section \f[I]Template variables\f[R] above.
.IP \[bu] 2
`\f[V]{{ viewer_doc_css_path }}\f[R]' is the CSS stylesheet path
required to format a HTML rendition of a Tp-Note document.
This path is hard-wired and it is understood by Tp-Note\[cq]s internal
web server.
.IP \[bu] 2
`\f[V]{{ viewer_highlighting_css_path }}\f[R]' is the CSS stylesheet
path required to highlight embedded source code.
This path is hard-wired and it is understood by Tp-Note\[cq]s internal
web server.
.IP \[bu] 2
`\f[V]{{ doc_fm_text }}\f[R]' is the raw UTF-8 copy of the header.
Not to be confounded with the dictionary variable
`\f[V]{{ fm_all }}\f[R]'.
.IP \[bu] 2
`\f[V]{{ doc_body_text | markup_to_html(extension=ext) | safe }}\f[R]'
is the note\[cq]s body as HTML rendition.
The parameter `\f[V]extension\f[R]' designates the markup language as
specified in the `\f[V]filename.extensions-*\f[R]' variables .
.IP \[bu] 2
`\f[V]{{ doc_text | markup_to_html | safe }}\f[R]' is the note\[cq]s raw
text as HTML rendition with clickable hyperlinks.
.IP \[bu] 2
`\f[V]{{ viewer_doc_js | safe }}\f[R]' is the JavaScript browser code
for live updates.
.IP \[bu] 2
`\f[V]{{ extension_default }}\f[R]' (c.f.
section \f[I]Template variables\f[R]).
.IP \[bu] 2
`\f[V]{{ username }}\f[R]' (c.f.
section \f[I]Template variables\f[R]).
.IP \[bu] 2
`\f[V]{{ lang }}\f[R]' (c.f.
section \f[I]Template variables\f[R]).
.IP \[bu] 2
`\f[V]{{ my_val | to_html | safe }}\f[R]' is the HTML rendition of the
`\f[V]my_val\f[R]' variable (c.f.
section \f[I]Template filter\f[R]).
.PP
Alternatively, the header enclosed by `\f[V]<pre>...</pre>\f[R]' can
also be rendered as a table:
.IP
.nf
\f[C]
  <table class=\[dq]fm\[dq]>
    <tr>
    <th class=\[dq]fmkey\[dq]>title:</th>
    <th class=\[dq]fmval\[dq]><b>
        {{ fm_title| default(value=\[aq]\[aq]) | to_html | safe }}</b>
    </th>
  </tr>
    <tr>
    <th class=\[dq]fmkey\[dq]>subtitle:</th>
    <th class=\[dq]fmval\[dq]>
        {{ fm_subtitle | default(value=\[aq]\[aq]) | to_html | safe }}
    </th>
  </tr>
  {% for k, v in fm_all| remove(key=\[aq]fm_title\[aq])|
                         remove(key=\[aq]fm_subtitle\[aq])|
  %}
    <tr>
    <th class=\[dq]fmkeygrey\[dq]>{{ k }}:</th>
    <th class=\[dq]fmvalgrey\[dq]>{{ v | to_html | safe }}</th>
  </tr>
  {% endfor %}
  </table>
\f[R]
.fi
.PP
The error page template `\f[V]tmpl_html.viewer_error\f[R]' (see below)
does not provide `\f[V]fm_*\f[R]' variables, because of possible header
syntax errors.
Instead, the variable `\f[V]{{ doc_error }}\f[R]' contains the error
message as raw UTF-8 and the variable
`\f[V]{{ doc_text | markup_to_html | safe }}\f[R]' the HTML rendition of
the text source with clickable hyperlinks:
.IP
.nf
\f[C]
[viewer_error]
<!DOCTYPE html>
<html lang=\[rs]\[dq]en\[rs]\[dq]>
<head>
<meta charset=\[rs]\[dq]UTF-8\[rs]\[dq]>
<title>Syntax error</title>
</head>
<body>
<h3>Syntax error</h3>
<p> in note file: <pre>{{ path }}</pre><p>
<div class=\[rs]\[dq]note-error\[rs]\[dq]>
<hr>
<pre>{{ doc_error }}</pre>
<hr>
</div>
{{ doc_text | markup_to_html | safe }}y
<script>{{ viewer_doc_js | safe }}</script>
</body>
</html>
\[aq]\[aq]\[aq]
\f[R]
.fi
.PP
\f[B]Customize the built-in HTML exporter\f[R]
.PP
Customizing Tp-Note\[cq]s HTML export function works the same way as
customizing the built-in viewer.
There are some slight differences though: The role of the
`\f[V]tmpl_html.viewer\f[R]' template - discussed above - is taken over
by the `\f[V]tmpl_html.exporter\f[R]' template:
.IP
.nf
\f[C]
{%- set ext = fm_file_ext | default(value=extension_default ) -%}
exporter = \[aq]\[aq]\[aq]
<!DOCTYPE html>
<html lang=\[dq]{{ fm_lang | default(value=\[aq]en\[aq]) }}\[dq]>
<head>
<meta charset=\[dq]utf-8\[dq]>
<title>{{ fm_title }}</title>
<style>
{{ exporter_doc_css | safe }}
{{ exporter_highlighting_css | safe }}
</style>
</head>
<body>
  <pre class=\[dq]doc-header\[dq]>{{ doc_fm_text }}</pre>
  <hr>
  <div class=\[dq]doc-body\[dq]>
    {{ doc_body_text| markup_to_html(extension=ext) | safe }}
  </div>
</body>
</html>
\f[R]
.fi
.PP
In this template the same \f[I]Tera\f[R] variables as in
`\f[V]tmpl_html.viewer\f[R]' are available, with one exception
`\f[V]{{ note_js }}\f[R]', which does not make sense in this context.
As the exporter prints possible rendition error messages on the console,
there is no equivalent to the `\f[V]tmpl_html.viewer_error\f[R]'
template.
Note, in contrast to the previous `\f[V]tmpl_html.viewer\f[R]' example,
the source code highlighting CSS code is now embedded into the HTML
output with:
.IP
.nf
\f[C]
<style>
{{ exporter_doc_css | safe }}
{{ exporter_highlighting_css | safe }}
</style>
\f[R]
.fi
.PP
Note, the `\f[V]safe\f[R]' filter disables the escaping of critical
characters in the CSS input.
We have no security concerns in this context, because we have full
control over the CCS input coming from the configuration file variables
`\f[V]tmpl_html.exporter_doc_css\f[R]' and
`\f[V]tmpl_html.exporter_highlighting_theme\f[R]'.
.SS Choose your favourite web browser as note viewer
.PP
Once the note is rendered into HTML, Tp-Note\[cq]s internal HTTP server
connects to a random port at the `\f[V]localhost\f[R]' interface where
the rendition is served to be viewed with a web browser.
Tp-Note\[cq]s configuration file contains a list
`\f[V]app_args.unix.browser\f[R]' with common web browsers and their
usual location on Unix like operating systems.
For other systems consult `\f[V]app_args.windows.browser\f[R]' and
`\f[V]app_args.macos.browser\f[R]'.
This list is executed top down until a web browser is found and
launched.
If you want to view your notes with a different web browser, simply
modify the `\f[V]app_args.unix.browser\f[R]' list and put your favourite
web browser on top.
Alternatively, you can set the `\f[V]TPNOTE_BROWSER\f[R]' environment
variable (cf.
examples in the chapter \f[I]ENVIRONMENT_VARIABLES\f[R] below).
.PP
In case none of the listed browsers can be found, Tp-Note switches into
a fallback mode with limited functionality, where it tries to open the
system\[cq]s default web browser.
A disadvantage is, that in fall back mode Tp-Note is not able to detect
when the user closes the web browser.
This might lead to situations, where Tp-Note\[cq]s internal HTTP server
shuts down to early.
In order to check if Tp-Note finds the selected web browser as intended,
invoke Tp-Note with `\f[V]tpnote --debug debug --popup --view\f[R]'.
.SH TEMPLATES
.PP
All \f[I]TP-Note\f[R]\[cq]s workflows are customizable through its
templates which are grouped in the `\f[V][tmpl]\f[R]' and in the
`\f[V][tmpl_html]\f[R]' section of Tp-Nots\[cq]s configuration file.
This chapter deals with `\f[V][tmpl]\f[R]' templates which are
responsible for generating Tp-Note files.
`\f[V][tmpl_html]\f[R]' templates concern only Tp-Note\[cq]s viewer
feature and are discussed in the chapters: Customize the built-in note
viewer_ and \f[I]Choose your favourite web browser as note viewer\f[R].
.PP
Tp-Note captures and stores its environment in \f[I]Tera variables\f[R].
For example, the variable `\f[V]{{ dir_path }}\f[R]' is initialized with
the note\[cq]s target directory.
The variable `\f[V]{{ clipboard }}\f[R]' contains the content of the
clipboard.
To learn more about Tera variables, launch Tp-Note with the
`\f[V]--debug trace\f[R]' option and observe what information it
captures from its environment.
.SS Template types
.PP
The content of a new note is composed by one of Tp-Note\[cq]s internal
customizable templates, hence the name Tp-Note, where \f[I]Tp\f[R]
stands for \[lq]template\[rq].
Which of the internal templates is applied depends on the context in
which Tp-Note is invoked: e.g.\ the template for clipboard text input is
called `\f[V]tmpl.from_clipboard_content\f[R]'.
If the clipboard contains text with a YAML header, the template
`\f[V]tmpl.from_clipboard_yaml_content\f[R]' is used.
.PP
In total, there are 5 different `\f[V]tmpl.*_content\f[R]' templates:
.IP \[bu] 2
`\f[V]tmpl.new_content\f[R]'
.IP \[bu] 2
`\f[V]tmpl.from_clipboard_content\f[R]'
.IP \[bu] 2
`\f[V]tmpl.from_clipboard_yaml_content\f[R]'
.IP \[bu] 2
`\f[V]tmpl.from_text_file_content\f[R]'
.IP \[bu] 2
`\f[V]tmpl.annotate_file_content\f[R]'
.PP
In general, the templates are designed in a way, that the text input
stream - usually originating from the clipboard - ends up in the body of
the note file, whereas the environment - such as the username - ends up
in the header of the note file.
.PP
Once the content of the new note is set by one of the content templates,
another template type comes into play: the so-called \f[I]filename
template\f[R].
Each content template has a corresponding filename template, e.g.:
.IP \[bu] 2
`\f[V]tmpl.new_filename\f[R]'
.IP \[bu] 2
`\f[V]tmpl.from_clipboard_filename\f[R]'
.IP \[bu] 2
`\f[V]tmpl.from_clipboard_yaml_filename\f[R]'
.IP \[bu] 2
`\f[V]tmpl.from_text_file_filename\f[R]'
.IP \[bu] 2
`\f[V]tmpl.annotate_file_filename\f[R]'
.IP \[bu] 2
`\f[V]tmpl.sync_filename\f[R]' (no corresponding content template)
.PP
As the name suggests, the role of a filename template is to determine
the filename of the new note.
This is done by evaluating (deserializing) it\[cq]s YAML header.
The values of the note\[cq]s YAML header fields are can be accessed in
filename templates through various `\f[V]{{ fm_<key> }}\f[R]'
dynamically created template variables.
For example the value of the YAML header field `\f[V]title:\f[R]' can be
accessed with `\f[V]{{ fm_title }}\f[R]'.
Once the filename is set, Tp-Note writes out the new note on disk.
.PP
Most of the above templates are dedicated to the creation of new note
files.
However, two of them have a special role: \f[I]prepend header to text
file\f[R] and \f[I]synchronize filename\f[R]:
.IP \[bu] 2
\f[I]Prepend header to text file\f[R] (new feature in Tp-Note v1.16.0):
When Tp-Note opens a regular text file without a YAML header, a new
header is prepended automatically.
It\[cq]s data originates mainly form the filename of the text file.
The templates applied in this use case are:
`\f[V]tmpl.from_text_file_content\f[R]' and
`\f[V]tmpl.from_text_file_filename\f[R]'.
.IP \[bu] 2
\f[I]Synchronize filename\f[R]: This function mode is invoked when
[Tp-Note] opens an existing note file, after it\[cq]s YAML header is
evaluated.
The extracted header information is then applied to the
`\f[V]tmpl.sync_filename\f[R]' template and the resulting filename is
compared with the actual filename on disk.
If they differ, [Tp-Note] renames the note file.
Note, the `\f[V]tmpl.sync_filename\f[R]' template operates on its own
without a corresponding content template.
.PP
Note, that in the operation mode \f[I]synchronize filename\f[R], the
header data overwrites the filename of the note, whereas in the
operation mode \f[I]prepend header\f[R] the filename data is copied into
the new prepended header.
Keep in mind, that even in the latter mode the filename might change
slightly.
This is because after the header creation with the
`\f[V]tmpl.from_text_file_content\f[R]' template, the
`\f[V]tmpl.from_text_file_filename\f[R]' template is applied, which
might cause a slight filename modification due to its sanitization
filters (cf.\ `\f[V]sanit()\f[R]' in the section \f[I]Template
filters\f[R]).
.PP
You can disable the \f[I]prepend header\f[R] feature by setting the
configuration file variable `\f[V]arg_default.add_header = false\f[R]'.
To disable all filename synchronization, set
`\f[V]arg_default.no_filename_sync = true\f[R]'.
This guarantees, that Tp-Note will never change neither the filename nor
the YAML header of an existing file.
.PP
For a more detailed description of templates and their defaults, please
consult the `\f[V]const\f[R]' definitions in Tp-Note\[cq]s source code
files `\f[V]config.rs\f[R]' and `\f[V]note.rs\f[R]' in the directory
`\f[V]tpnote-lib/src/\f[R]'.
.SS Template variables
.PP
All Tera template variables and
functions (https://tera.netlify.com/%20docs/#templates) can be used
within Tp-Note\[cq]s templates.
For example `\f[V]{{ get_env(name=\[aq]LANG\[aq]) }}\[aq]\f[R] gives you
access to the'\f[V]LANG\f[R]\[cq] environment variable.
.PP
In addition, Tp-Note defines the following variables:
.IP \[bu] 2
`\f[V]{{ path }}\f[R]' is the canonicalized fully qualified path name
corresponding to Tp-Note\[cq]s positional command line parameter
`\f[V]<path>\f[R]'.
If none was given on the command line, `\f[V]{{ path }}\f[R]' contains
the current working directory path.
.IP \[bu] 2
`\f[V]{{ dir_path }}\f[R]' is identical to `\f[V]{{ path }}\f[R]' with
one exception: if `\f[V]{{ path }}\f[R]' points to a file, the last
component (the file name) is omitted and only the directory path is
retained.
If `\f[V]{{ path }}\f[R]' points to a directory,
`\f[V]{{ dir_path }}\f[R]' equals `\f[V]{{ path }}\f[R]'.
.IP \[bu] 2
`\f[V]{{ note_fm_text }}\f[R]': is the header as raw text of the file
`\f[V]{{ path }}\f[R]' points to.
Note, this variable is only available in the templates
`\f[V]from_text_file_*\f[R]', `\f[V]sync_filename\f[R]' and the HTML
templates below.
.IP \[bu] 2
`\f[V]{{ note_body_text }}\f[R]': is the content of the file
`\f[V]{{ path }}\f[R]' points to.
If the file does not start with a front matter, this variable holds the
whole content.
Note, this variable is only available in the templates
`\f[V]from_text_file_*\f[R]', `\f[V]sync_filename\f[R]' and the HTML
templates below.
.IP \[bu] 2
`\f[V]{{ note_file_date }}\f[R]': is the file system creation date of
the file `\f[V]{{ path }}\f[R]' points to.
Note, this variable is only available in the templates
`\f[V]from_text_file_*\f[R]', `\f[V]sync_filename\f[R]' and the HTML
templates below.
.IP \[bu] 2
`\f[V]{{ clipboard }}\f[R]' is the complete clipboard text.
In case the clipboard\[cq]s content starts with a YAML header, the
latter does not appear in this variable.
.IP \[bu] 2
`\f[V]{{ clipboard_header }}\f[R]' is the YAML section of the clipboard
data, if one exists.
Otherwise: empty string.
.IP \[bu] 2
`\f[V]{{ stdin }}\f[R]' is the complete text content originating from
the input stream `\f[V]stdin\f[R]'.
This stream can replace the clipboard when it is not available.
In case the input stream\[cq]s content starts with a YAML header, the
latter does not appear in this variable.
.IP \[bu] 2
`\f[V]{{ stdin_header }}\f[R]' is the YAML section of the input stream,
if one exists.
Otherwise: empty string.
.IP \[bu] 2
`\f[V]{{ extension_default }}\f[R]' is the default extension for new
notes (can be changed in the configuration file),
.IP \[bu] 2
`\f[V]{{ username }}\f[R]' is the content of the first non-empty
environment variable: `\f[V]TPNOTE_USER\f[R]', `\f[V]LOGNAME\f[R]',
`\f[V]USER\f[R]' or `\f[V]USERNAME\f[R]'.
.IP \[bu] 2
`\f[V]{{ lang }}\f[R]' contains the user\[cq]s language tag as defined
in RFC 5646 (http://www.rfc-editor.org/rfc/rfc5646.txt).
Not to be confused with the UNIX `\f[V]LANG\f[R]' environment variable
from which this value is derived under Linux/macOS.
Under Windows, the user\[cq]s language tag is queried through the
WinAPI.
If defined, the environment variable `\f[V]TPNOTE_LANG\f[R]' overwrites
the value of `\f[V]{{ lang }}\f[R]' (all operating systems).
.PP
The following `\f[V]{{ fm_* }}\f[R]' variables are typically generated,
\f[I]after\f[R] a content template was filled in with data: For example
a field named `\f[V]title:\f[R]' in the content template
`\f[V]tmpl.new_content\f[R]' will generate the variable
`\f[V]fm_title\f[R]' which can then be used in the corresponding
`\f[V]tmpl.new_filename\f[R]' filename template.
`\f[V]{{ fm_* }}\f[R]' variables are generated dynamically.
This means, a YAML front-matter variable `\f[V]foo:\f[R]' in a note will
generate a `\f[V]{{ fm_foo }}\f[R]' template variable.
On the other hand, a missing `\f[V]foo:\f[R]' will cause
`\f[V]{{ fm_foo }}\f[R]' to be undefined.
.PP
Please note that `\f[V]{{ fm_* }}\f[R]' variables are only available in
filename templates and in the
`\f[V]tmpl.from_clipboard_yaml_content\f[R]' content template.
.IP \[bu] 2
`\f[V]{{ fm_title }}\f[R]' is the `\f[V]title:\f[R]' as indicated in the
YAML front-matter of the note.
.IP \[bu] 2
`\f[V]{{ fm_subtitle }}\f[R]' is the `\f[V]subtitle:\f[R]' as indicated
in the YAML front matter of the note.
.IP \[bu] 2
`\f[V]{{ fm_author }}\f[R]' is the `\f[V]author:\f[R]' as indicated in
the YAML front-matter of the note.
.IP \[bu] 2
`\f[V]{{ fm_lang }}\f[R]' is the `\f[V]lang:\f[R]' as indicated in the
YAML front-matter of the note.
.IP \[bu] 2
`\f[V]{{ fm_file_ext }}\f[R]' holds the value of the optional YAML
header variable `\f[V]file_ext:\f[R]' (e.g.\ `\f[V]file_ext: rst\f[R]').
.IP \[bu] 2
`\f[V]{{ fm_sort_tag }}\f[R]': The sort tag variable as defined in the
YAML front matter of this note
(e.g.\ `\f[V]sort_tag: \[aq]20200312\[aq]\f[R]').
.IP \[bu] 2
`\f[V]{{ fm_all }}\f[R]': is a collection (map) of all defined
`\f[V]{{ fm_* }}\f[R]' variables.
It is used in the `\f[V]tmpl.from_clipboard_yaml_content\f[R]' template,
typically in a loop like:
.RS 2
.IP
.nf
\f[C]
{% for key, value in fm_all %}{{ key }}: {{ value | json_encode }}
{% endfor %}
\f[R]
.fi
.RE
.PP
Important: there is no guarantee, that any of the above
`\f[V]{{ fm_* }}\f[R]' variables are defined!
Depending on the last content template result, certain variables might
be undefined.
Please take into consideration, that a defined variable might contain
the empty string `\f[V]\[dq]\[dq]\f[R]'.
Creating a new note file with a content template, the note\[cq]s header
is parsed into `\f[V]{{ fm_* }}\f[R]' variables.
The latter are then type checked according configurable rules.
The rules are defined in `\f[V]tmpl.filter_assert_precondition\f[R]'
.PP
For a more detailed description of the available template variables,
please consult the `\f[V]const\f[R]' definitions in Tp-Note\[cq]s source
code file `\f[V]note.rs\f[R]'.
.SS Template filters
.PP
In addition to \f[I]Tera\f[R]\[cq]s built-in
filters (https://tera.netlify.app/docs/#built-in-filters), Tp-Note comes
with some additional filters, i.e.: `\f[V]append(newline=true)\f[R]',
`\f[V]append(with=...)\f[R]', `\f[V]cut\f[R]',
`\f[V]file_copy_counter\f[R]', `\f[V]file_ext\f[R]',
`\f[V]file_name\f[R]', `\f[V]file_sort_tag\f[R]', `\f[V]file_stem\f[R]',
`\f[V]get_lang\f[R]', `\f[V]heading\f[R]',
`\f[V]insert(key=..., value=...)\f[R]', `\f[V]link_dest\f[R]',
`\f[V]link_text\f[R]', `\f[V]link_title\f[R]', `\f[V]map_lang\f[R]',
`\f[V]prepend\f[R]', `\f[V]prepend(newline=true)\f[R]',
`\f[V]prepend(with=...)\f[R]', `\f[V]prepend(with_sort_tag=...)\f[R]',
`\f[V]remove(key=)\f[R]' `\f[V]sanit\f[R]', `\f[V]to_html\f[R]',
`\f[V]to_yaml\f[R]', `\f[V]to_yaml(key=...)\f[R]',
`\f[V]to_yaml(tab=...)\f[R]' and `\f[V]trim_file_sort_tag\f[R]'.
.PP
A filter is always used together with a variable.
Here are some examples:
.IP \[bu] 2
`\f[V]{{ path |\ file_name }}\f[R]' returns the final component of
`\f[V]{{ path }}\f[R]'.
If `\f[V]{{ path }}\f[R]' points to a file, the filter returns the
complete filename including its sort tag, stem, copy-counter, dot and
extension.
If the `\f[V]<path>\f[R]' points to a directory, the filter returns the
final directory name.
.IP \[bu] 2
`\f[V]{{ path | file_sort_tag }}\f[R]' is the sort tag (numerical
filename prefix) of the final component of `\f[V]{{ path }}\f[R]',
e.g.\ `\f[V]01-23_9\f[R]' or `\f[V]20191022\f[R]'.
It is similar to `\f[V]{{ path |\ file_name }}\f[R]' but without
returning its stem, copy-counter and extension.
.IP \[bu] 2
`\f[V]{{ path | file_sort_tag | assert_valid_sort_tag }}\f[R]' does not
change the above output, but the filter asserts at runtime, that the
resulting type is either `\f[V]String\f[R]' or `\f[V]Number\f[R]' and
that all characters are part of the set
`\f[V]filename.sort_tag_chars\f[R]'.
The additional runtime check simplifies template debugging.
.IP \[bu] 2
`\f[V]{{ path |\ file_stem }}\f[R]' is similar to
`\f[V]{{ path |\ file_name }}\f[R]' but without its sort tag,
copy-counter and extension.
Only the stem of `\f[V]{{ path }}\f[R]'\[cq]s last component is
returned.
.IP \[bu] 2
`\f[V]{{ path |\ file_copy_counter }}\f[R]' is similar to
`\f[V]{{ path |\ file_name }}\f[R]' but without its sort tag, stem and
extension.
Only the copy counter of `\f[V]{{ path }}\f[R]'\[cq]s last component is
returned.
.IP \[bu] 2
`\f[V]{{ path | file_ext }}\f[R]' is `\f[V]{{ path }}\f[R]'\[cq]s file
extension without dot (period), e.g.\ `\f[V]txt\f[R]' or `\f[V]md\f[R]'.
.IP \[bu] 2
`\f[V]{{ path | file_ext |\ prepend(with=\[aq].\[aq]) }}\f[R]' is
`\f[V]{{ path }}\f[R]'\[cq]s file extension with dot (period),
e.g.\ `\f[V].md\f[R]' or `\f[V].md\f[R]'.
.IP \[bu] 2
`\f[V]{{ path | trim_file_sort_tag }}\f[R]' returns the final component
of `\f[V]path\f[R]' which might be a directory name or a file name.
Unlike the `\f[V]file_name\f[R]' filter (which also returns the final
component), `\f[V]trim_file_sort_tag\f[R]' trims the sort tag if there
is one.
.IP \[bu] 2
`\f[V]{{ dir_path | trim_file_sort_tag }}\f[R]' returns the final
component of `\f[V]dir_path\f[R]' (which is the final directory name in
`\f[V]{{ path }}\f[R]').
Unlike the `\f[V]file_name\f[R]' filter (which also returns the final
component), `\f[V]trim_file_sort_tag\f[R]' trims the sort tag if there
is one.
.IP \[bu] 2
`\f[V]{{ clipboard | cut }}\f[R]' is the first 200 bytes from the
clipboard.
.IP \[bu] 2
`\f[V]{{ clipboard | heading }}\f[R]' is the clipboard\[cq]s content
until the end of the first sentence, or the first newline.
.IP \[bu] 2
`\f[V]{{ clipboard | link_text }}\f[R]' is the name of the first
Markdown or ReStructuredText formatted link in the clipboard.
.IP \[bu] 2
`\f[V]{{ clipboard | link_dest }}\f[R]' is the URL of the first Markdown
or ReStruncturedText formatted link in the clipboard.
.IP \[bu] 2
`\f[V]{{ clipboard | link_title }}\f[R]' is the title of the first
Markdown or ReStruncturedText formatted link in the clipboard.
.IP \[bu] 2
`\f[V]{{ username | capitalize | to_yaml(key=\[aq]author\[aq],tab=12) }}\f[R]'
is the capitalized YAML encoded username.
As all YAML front-matter is YAML encoded, the `\f[V]to_yaml\f[R]' filter
must be appended to any template variable placed in the front-matter
block.
The `\f[V]key=\[aq]author\[aq]\f[R]' parameter prepends the key to the
capitalized username, e.g.: `\f[V]autor:      John\f[R]'.
Note, the first letter of `\f[V]John\f[R]' starts at the tabulator
position `\f[V]tab=12\f[R]'.
.IP \[bu] 2
`\f[V]{{ fm_subtitle | sanit }}\f[R]' is the note\[cq]s subtitle as
defined in its front matter, sanitized in a file system friendly form.
Special characters are omitted or replaced by `\f[V]-\f[R]' and
`\f[V]_\f[R]'.
See the section \f[I]Filename template convention\f[R] for more details
about this filter.
.IP \[bu] 2
`\f[V]{{ fm_title | sanit | prepend(with_sort_tag=path|file_sort_tag) }}\f[R]'
is the note\[cq]s title as defined in its front-matter.
Same as above, but the title string is prepended with the note\[cq]s
\f[I]sort_tag\f[R] and with a `\f[V]filename.sort_tag_separator\f[R]'
(by default `\f[V]-\f[R]').
Eventually, a second `\f[V]filename.sort_tag_extra_separator\f[R]' (by
default `\f[V]\[aq]\[aq]\f[R]') is inserted after the first to
guarantee, that one of the separators unequivocally marks the end of the
\f[I]sort_tag\f[R].
This might be necessary to avoid ambiguity in case the
`\f[V]fm_title\f[R]' starts with a character defined in the
`\f[V]filename.sort_tag_chars\f[R]' set.
.IP \[bu] 2
`\f[V]{{ fm_all | remove(key=\[aq]fm_title\[aq]) | remove(key=\[aq]fm_author\[aq]) | to_yaml }}\f[R]'
renders the collection (map) `\f[V]fm_all\f[R]', exclusive of the
variables `\f[V]fm_title\f[R]' and `\f[V]fm_author\f[R]' to YAML.
Note, that the filter `\f[V]to_yaml\f[R]' has no parameter
`\f[V]key\f[R]' in this context.
.IP \[bu] 2
`\f[V]{{ fm_all | insert(key=\[aq]fm_author\[aq], value=\[aq]Getreu\[aq]) | to_yaml}}\f[R]'
takes the collection (map) `\f[V]fm_all\f[R]', inserts the key/value
`\f[V]fm_author\f[R]'/`\f[V]Jens\f[R]' and renders the result into YAML.
Note, that the filter `\f[V]to_yaml\f[R]' has no parameter
`\f[V]key\f[R]' in this context.
.IP \[bu] 2
`\f[V]{{ fm_all | to_yaml | append(newline=true) }}\f[R]' renders the
collection (map) `\f[V]fm_all\f[R]' into YAML.
If the collection is empty, the result is the empty string.
Otherwise, the YAML rendition is appended with a newline character.
.IP \[bu] 2
`\f[V]{{ fm_all | to_html | safe }}\f[R]' renders the collection (map)
`\f[V]fm_*\f[R]' into HTML.
The `\f[V]to_html\f[R]' must be followed by a `\f[V]safe\f[R]' filter to
pass through the HTML formatting of objects and arrays.
.IP \[bu] 2
`\f[V]{{ note_body_text | get_lang }}\f[R]' determines the natural
language of the variable `\f[V]{{ note_body_text }}\f[R] and returns the
result as ISO 639-1 language code.
The template filter'\f[V]{{ get_lang }}\f[R]\[cq] can be configured with
the configuration file variable `\f[V]tmpl.filter_get_lang\f[R]'.
The latter defines a list of ISO 639-1 codes, the detection algorithm
considers as possible language candidates.
Keep this list as small as possible, because language detection is
computationally expensive.
A long candidate list may slow down the note file creation workflow.
If the detection algorithm can not determine the language of
`\f[V]{{ note_body_text }}\f[R]', the filter `\f[V]get_lang\f[R]'
returns the empty string.
.IP \[bu] 2
`\f[V]{{ note_body_text | get_lang | map_lang }}\f[R]' maps the detected
ISO 638-1 language code to a complete IETF BCP 47 language tag, usually
containing the region subtag.
For example the input `\f[V]en\f[R]' results in `\f[V]en-US\f[R]'.
This additional mapping is useful because the detection algorithm can
not determine the region automatically.
The mapping can be configured by adjusting the configuration file
variable `\f[V]tmpl.filter_map_lang\f[R]'.
If a language is not listed in the `\f[V]tmpl.filter_map_lang\f[R]'
filter configuration, the input is passed through, e.g.\ `\f[V]fr\f[R]'
results in `\f[V]fr\f[R]', or, the empty string results in an empty
string.
.IP \[bu] 2
`\f[V]{{ note_body_text | get_lang | map_lang(default=lang) }}\f[R]'
adds an extra mapping for the `\f[V]map_lang\f[R]' filter: when the
input of the `\f[V]map_lang\f[R]' filter is the empty string, then
it\[cq]s output becomes the value of the `\f[V]{{ lang }}\f[R]'
variable.
.SS Content template conventions
.PP
Tp-Note distinguishes two template types: content templates are used to
create the note\[cq]s content (front-matter and body) and the
corresponding filename templates `\f[V]tmpl.*_filename\f[R]' are used to
calculate the note\[cq]s filename.
By convention, content templates appear in the configuration file in
variables named `\f[V]tmpl.*_content\f[R]'.
.PP
Strings in the front matter section of content templates are YAML
encoded.
Therefore, all variables used in the front-matter must pass an
additional `\f[V]to_yaml()\f[R]'-filter.
For example, the variable `\f[V]{{ dir_path | file_stem() }}\f[R]'
becomes
`\f[V]{{ dir_path | file_stem() | to_yaml(key=\[aq]title\[aq]) }}\f[R]'
or, shorter:
`\f[V]{{ dir_path | file_stem | to_yaml(key=\[aq]title\[aq]) }}\f[R]'.
.PP
When given with a key, the `\f[V]to_yaml(key=\[aq]...\[aq])\f[R]' filter
accepts any input type, whereas the short form `\f[V]to_yaml()\f[R]'
requires an `\f[V]Value::Object\f[R]' type as input.
The latter is often followed be the `\f[V]append(newline=true)\f[R]'
filter appending a newline.
.SS Filename template conventions
.PP
By convention, filename templates appear in the configuration file in
variables named `\f[V]tmpl.*_filename\f[R]'.
When a content template creates a new note, the corresponding filename
template is called afterwards to calculate the filename of the new note.
Please note that, the filename template `\f[V]tmpl.sync_filename\f[R]'
has a special role as it synchronizes the filename of existing note
files.
Besides this, as we are dealing with filenames we must guarantee, that
the filename templates produce only file system friendly characters.
For this purpose Tp-Note provides the additional Tera filter
`\f[V]sanit\f[R]':
.PP
The `\f[V]sanit()\f[R]' filter transforms a string in a file system
friendly from.
This is done by replacing forbidden characters like `\f[V]?\f[R]' and
`\f[V]\[rs]\[rs]\f[R]' with `\f[V]_\f[R]' or space.
This filter can be used with any variable, but is most useful with
filename templates.
For example, in the `\f[V]tmpl.sync_filename\f[R]' template, we find the
expression `\f[V]{{ subtitle | sanit }}\f[R]'.
Note that the filter recognizes strings that represent a so-called dot
file name and treats them a little differently by prepending them with
an apostrophe: a dot file is a file whose name starts with `\f[V].\f[R]'
and that does not contain whitespace.
It may or may not end with a file extension.
The apostrophe preserves the following dot from being filtered.
.PP
The `\f[V]prepend(with_sort_tag=<...>\f[R]' filter is similar to the
`\f[V]prepend(with=<...>\f[R]' filter, with two exceptions:
.IP "1." 3
If `\f[V]filename.sort_tag_separator\f[R]' is defined (by default
`\f[V]-\f[R]'), it is automatically inserted between the sort-tag and
the input string.
.IP "2." 3
In some cases an additional separator
`\f[V]filename.sort_tag_extra_separator\f[R]' (by default
`\f[V]\[aq]\f[R]') may be inserted as well.
.PP
Both separators guarantee that the end of a sort-tag is detected
unequivocally.
For example, when the input string starts with a digit
`\f[V]0123456789\f[R]' or `\f[V]-_\f[R]', the string is prepended with
\f[V]-\[aq]\f[R], e.g.
`\f[V]1-The Show Begins\f[R]' becomes
`\f[V]\[aq]1-The Show Begins\f[R]'.
The `\f[V]prepend(with_sort_tag=<...>)\f[R]' filter must be applied to
the first variable, e.g.\ 
`\f[V]{{ fm_title | sanit | prepend(with_separator=path|file_sort_tag )}\f[R]'.
This way, it is always possible to univocally distinguish the sort-tag
from the rest of the filename.
Note, the default sort-tag separators can be changed with the
configuration variables `\f[V]filename.sort_tag_separator\f[R]' and
`\f[V]filename.sort_tag_extra_separator\f[R]'.
For more details please consult the \f[I]Customize the filename
synchronization scheme\f[R] chapter.
.PP
In filename templates most variables must pass the `\f[V]sanit\f[R]'
filter.
Exception to this rule are sort-tag expressions like
`\f[V]{{ path | file_sort_tag }}\f[R]' and
`\f[V]{{ dir_path | file_sort_tag }}\f[R]'.
As the latter are guaranteed to contain only the file system friendly
characters `\f[V]0123456789 -_\f[R]', no additional filtering is
required.
Please note, that in this case a `\f[V]sanit\f[R]'-filter would
needlessly restrict the value range of sort-tags because they may
contain characters, which the `\f[V]sanit\f[R]'-filter screens out when
they appear in leading or trailing position.
For this reason one must not use the `\f[V]sanit\f[R]'-filter together
with `\f[V]{{ path | file_sort_tag }}\f[R]' or
`\f[V]{{ dir_path |file_sort_tag }}\f[R]'.
.SH SECURITY AND PRIVACY CONSIDERATIONS
.PP
As discussed above, Tp-Note\[cq]s built-in viewer sets up an HTTP server
on the `\f[V]localhost\f[R]' interface with a random port number.
.PP
For security reasons, Tp-Note limits the set of files the viewer is able
to publish.
To summarize, a file is only served:
.IP "1." 3
when it is referenced in one of the currently viewed Tp-Note files,
.IP "2." 3
when its file extension is registered with the
`\f[V]viewer.served_mime_type\f[R]' list,
.IP "3." 3
if the number of so far viewed Tp-Note files,
`\f[V]viewer.displayed_tpnote_count_max\f[R]' is not exceeded,
.IP "4." 3
when it\[cq]s located under a directory containing a marker file named
`\f[V].tpnote.toml\f[R]' (without marker file this condition is void).
.PP
The HTTP server runs as long as the launched web browser window is open.
Note, that the server not only exposes the displayed note file, but also
all referenced inline images and other linked TP-Note files.
Internally, the viewer maintains a list of \f[I]referenced local
URLs\f[R].
For security reasons, only listed files are served.
To limit data exfiltration in case an attacker gains access to an
account on your machine, the number of served Tp-Note files is limited
by the configurable value `\f[V]viewer.displayed_tpnote_count_max\f[R]'.
.PP
In addition to the above quantitative restriction, Tp-Note\[cq]s
built-in viewer serves only files whose file extensions are registered
with the `\f[V]viewer.served_mime_type\f[R]' configuration file
variable.
The latter allows disabling the \f[I]follow links to other Tp-Note
files\f[R] feature by removing all `\f[V]text/*\f[R]' mime types from
that list.
.PP
Another security feature is the `\f[V].tpnote.toml\f[R]' marker file.
When Tp-Note opens a note file, it checks all directories above, one by
one, until it finds the marker file `\f[V].tpnote.toml\f[R]'.
Tp-Note\[cq]s viewer will never serve a file located outside the root
directory and its children.
When no `\f[V].tpnote.toml\f[R]' file is found, the root directory is
set to `\f[V]/\f[R]', which disables this security feature.
.PP
As Tp-Note\[cq]s built-in viewer binds to the `\f[V]localhost\f[R]'
interface, the exposed files are in principle accessible to all
processes running on the computer.
As long as only one user is logged into the computer at a given time, no
privacy concern is raised: any potential attacker must be logged in, in
order to access the \f[V]localhost\f[R] HTTP server.
.PP
This is why on systems where multiple users are logged in at the same
time, it is recommended to disable Tp-Note\[cq]s internal HTTP server by
setting the configuration file variable
`\f[V]arg_default.edit = true\f[R]'.
Alternatively, you can also compile Tp-Note without the
`\f[V]viewer\f[R]' feature.
Note, that even if the viewer feature disabled, the `\f[V]--export\f[R]'
command line option still works: This allows the authorized user to
render the note to HTML manually.
.PP
\f[B]Summary\f[R]: As long as Tp-Note\[cq]s built-in note viewer is
running, the note file and all its referenced (image) files are exposed
to all users logged into the computer at that given time.
This concerns only local users, Tp-Note never exposes any information to
the network or on the Internet.
.SH ENVIRONMENT VARIABLES
.PP
LANG
.RS
.PP
Tp-Note stores the user\[cq]s locale settings - originating from the
environment variable `\f[V]LANG\f[R]' (or the Windows registry) - in the
template variable `\f[V]{{ lang }}\f[R]'.
When the environment variable `\f[V]TPNOTE_LANG\f[R]' is set, it
overwrites the locale setting stored in `\f[V]{{ lang }}\f[R]'.
`\f[V]man locale\f[R]' describes the data format of `\f[V]LANG\f[R]', a
typical value is `\f[V]en_GB.UTF-8\f[R]'.
.RE
.PP
TPNOTE_CONFIG
.RS
.PP
When set, the environment variable replaces the default path where
Tp-Note loads or stores its configuration file.
It has the same effect as the command line option `\f[V]--config\f[R]'.
If both are present, that latter takes precedence.
.RE
.PP
TPNOTE_LANG
.RS
.PP
Tp-Note stores the user\[cq]s locale settings - originating from the
environment variable `\f[V]LANG\f[R]' (or the Windows registry) - in the
template variable `\f[V]{{ lang }}\f[R]'.
When the environment variable `\f[V]TPNOTE_LANG\f[R]' is set, it
overwrites the locale setting stored in `\f[V]{{ lang }}\f[R]'.
Unlike `\f[V]LANG\f[R]', the environment variable
`\f[V]TPNOTE_LANG\f[R]' is encoded as IETF BCP 47 language tag,
e.g.\ `\f[V]en-US\f[R]'.
.RE
.PP
TPNOTE_LANG_DETECTION
.RS
.PP
If set, this variable overwrites the configuration file variables
`\f[V]tmpl.filter_get_lang\f[R]' and `\f[V]tmpl.filter_map_lang\f[R]',
thus selecting potential language candidates for Tp-Note\[cq]s natural
language detection.
The string contains a comma and space separated list of ISO 63901 codes,
e.g.
`\f[V]fr\f[R]' or IETF BCP 47 tags, e.g.\ `\f[V]fr-FR\f[R]'.
Here is an example of a complete string:
`\f[V]de-DE, en, fr-FR, hu\f[R]'.
The user\[cq]s default locale `\f[V]{{ lang }}\f[R]' is automatically
added to the list.
Note, that the language detection algorithm determines only the language
subtag, e.g.\ `\f[V]en\f[R]'.
The region subtag will be added as indicated in your configuration.
Subsequent entries that differ only in the region subtag,
e.g.\ `\f[V]en-GB, en-US\f[R]' are ignored.
.RE
.RS
.PP
The empty string disables the automatic language detection.
.RE
.RS
.IP
.nf
\f[C]
TPNOTE_LANG_DETECTION=\[dq]\[dq] tpnote
\f[R]
.fi
.RE
.RS
.PP
For debugging observe the value of `\f[V]SETTINGS\f[R]' in the debug
log:
.RE
.RS
.IP
.nf
\f[C]
TPNOTE_LANG_DETECTION=\[dq]de-DE, en, fr-FR\[dq] tpnote -d trace -b
\f[R]
.fi
.RE
.PP
TPNOTE_BROWSER
.RS
.PP
If set, this variable take precedence over the configuration file
variable `\f[V]app_args.browser\f[R]'.
While the latter is a list describing how to invoke various web
browsers, `\f[V]TPNOTE_BROWSER\f[R]' contains a string invoking one
particular browser, exactly as one would do in a shell: the whitespace
separated tokens list contains: the path name of the application, and
all its flags and options.
For example:
.RE
.RS
.IP
.nf
\f[C]
TPNOTE_BROWSER=\[dq]chromium --new-window --incognito\[dq] tpnote
\f[R]
.fi
.RE
.RS
.PP
The above instructs Tp-Note to start the web browser
`\f[V]chromium\f[R]' with the flags `\f[V]--new-window\f[R]' and
`\f[V]--incognito\f[R]'.
Unlike in a shell, the backslash and quote characters have no special
meaning.
Instead, all tokens are \f[I]percent encoded\f[R],
e.g.\ `\f[V]my path\f[R]' becomes `\f[V]my%20path\f[R]'.
.RE
.RS
.PP
The empty string disables the launch of the browser the same way as
`\f[V]--edit\f[R]':
.RE
.RS
.IP
.nf
\f[C]
TPNOTE_BROWSER=\[dq]\[dq] tpnote
\f[R]
.fi
.RE
.RS
.PP
is equivalent to:
.RE
.RS
.IP
.nf
\f[C]
tpnote --edit
\f[R]
.fi
.RE
.PP
TPNOTE_EDITOR
.RS
.PP
If set, and you are working on a graphical desktop, this variable takes
precedence over the configuration file variable
`\f[V]app_args.editor\f[R]'.
While the latter is a list describing how to invoke various file
editors, `\f[V]TPNOTE_EDITOR\f[R]' contains a string invoking one
particular file editor, exactly as one would do on a shell: the
whitespace separated tokens list contains: the path name of the
application, and all its flags and options.
For example:
.RE
.RS
.IP
.nf
\f[C]
TPNOTE_EDITOR=\[dq]geany -sim\[dq] tpnote
\f[R]
.fi
.RE
.RS
.PP
The above instructs Tp-Note to start the editor `\f[V]geany\f[R]' with
the flags `\f[V]-sim\f[R]'.
Unlike with shell tokens, the backslash and quote characters have no
special meaning.
Instead, all tokens are \f[I]percent encoded\f[R].
Consider the following example where the space character is expressed as
`\f[V]%20\f[R]':
.RE
.RS
.IP
.nf
\f[C]
TPNOTE_EDITOR=\[dq]geany -sim -c \[ti]/my%20config/\[dq] tpnote
\f[R]
.fi
.RE
.RS
.PP
The empty string disables the launch of the editor the same way as the
command line option `\f[V]--view\f[R]' does:
.RE
.RS
.IP
.nf
\f[C]
TPNOTE_EDITOR=\[dq]\[dq] tpnote
\f[R]
.fi
.RE
.RS
.PP
is equivalent to:
.RE
.RS
.IP
.nf
\f[C]
tpnote --view
\f[R]
.fi
.RE
.PP
TPNOTE_EDITOR_CONSOLE
.RS
.PP
If set, and you are working on a virtual console, this variable takes
precedence over the configuration file variable
`\f[V]app_args.editor_console\f[R]', which defines the command line
parameters for invoking a terminal based text editor, such as Emacs, Vim
or Helix.
Otherwise, the syntax and the operation are the same as with
`\f[V]TPNOTE_EDITOR\f[R] hereinabove'.
Example of use:
.RE
.RS
.IP
.nf
\f[C]
sudo TPNOTE_EDITOR_CONSOLE=\[dq]nvim\[dq] tpnote
\f[R]
.fi
.RE
.PP
TPNOTE_EXTENSION_DEFAULT
.RS
.PP
If set, this variable takes precedence over the configuration file
variable `\f[V]filename.extension_default\f[R]', which defines the file
extension of new note files.
In order to activate the appropriate markup renderer make sure, that the
value given here is listed in `\f[V]filename.extensions\f[R]'.
.RE
.PP
TPNOTE_USER, LOGNAME, USER, USERNAME
.RS
.PP
The template variable `\f[V]{{ username }}\f[R]' is the content of the
first non-empty environment variable: `\f[V]TPNOTE_USER\f[R]',
`\f[V]LOGNAME\f[R]', `\f[V]USER\f[R]' or `\f[V]USERNAME\f[R]'.
.RE
.SH EXIT STATUS
.PP
The exit status is `\f[V]0\f[R]' when the note file was processed
without error or `\f[V]1\f[R]' otherwise.
If Tp-Note can not read or write its configuration file, the exit status
is `\f[V]5\f[R]'.
.PP
When `\f[V]tpnote -n -b <FILE>\f[R]' returns the code `\f[V]0\f[R]', the
note file has a valid YAML header with a `\f[V]title:\f[R]' field.
In addition, when `\f[V]tpnote -n -b -x - <FILE>\f[R]' returns the code
`\f[V]0\f[R]', the note\[cq]s body was rendered without error.
.SH RESOURCES
.PP
Tp-Note it hosted on:
.IP \[bu] 2
Gitlab: <https://gitlab.com/getreu/tp-note>.
.IP \[bu] 2
Github (mirror): <https://github.com/getreu/tp-note> and on
.SH COPYING
.PP
Copyright (C) 2016-2021 Jens Getreu
.PP
Licensed under either of
.IP \[bu] 2
Apache Licence, Version 2.0 <http://www.apache.org/licenses/LICENSE-2.0>
.IP \[bu] 2
MIT licence <http://opensource.org/licenses/MIT>
.PP
at your option.
.SS Contribution
.PP
Unless you explicitly state otherwise, any contribution intentionally
submitted for inclusion in the work by you, as defined in the Apache-2.0
licence, shall be dual licensed as above, without any additional terms
or conditions.
Licensed under the Apache Licence, Version 2.0 (the \[lq]Licence\[rq]);
you may not use this file except in compliance with the Licence.
.SH AUTHORS
.PP
Jens Getreu <getreu@web.de>
.SH NOTES
.SS [1]
.PP
The variables `\f[V]{{ fm_title }}\f[R]' and
`\f[V]{{ fm_subtitle }}\f[R]' reflect the values in the note\[cq]s front
matter.
.SH AUTHORS
Jens Getreu.
