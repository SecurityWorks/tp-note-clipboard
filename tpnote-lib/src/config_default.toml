[filename]

# List of characters that can be part of a _sort tag_.
# Besides the characters listed here, the digits `0..9` and
# the lowercase letters `a..z` are always valid sort-tag characters. 
sort_tag.extra_chars = ".-_="

# If empty, the first character which is not in `filename.sort_tag.extra_chars`
# marks the end of a sort tag.
# If not empty, a _sort_tag_ is only valid, when is its followed by
# `filename.sort_tag.separator`. A _sort_tag_ never ends with a
# `filename.sort_tag.separator`, if it does it stripped. In other positions
# the separator may appear.
sort_tag.separator = "-"

# In case the file stem starts with a character in `sort_tag.extra_chars` the
# `sort_tag.extra_separator` character is inserted in order to separate both
# parts when the filename is read next time.
sort_tag.extra_separator = "'"

# A sort-tag can have several counters. A counter can a set of digits or
# a set of lower case letters. A valid sort-tag (sequential or chronological)
# can have at most this number of letters in succession. 
sort_tag.letters_in_succession_max = 2

# A criterium to decide if a sort tag is sequential or not: a sequential
# sort-tag must have a maximum of this number of digits in succession.
# We set this to `3` assuming, that the chronological sort-tag contains some 
# year, e.g. # `20231028` or `2023-10-28`. We require sequential sort-tags 
# to have shorter numbers to satisfy this criterium, e.g. `3.1.123` or `3a123`.
sort_tag.sequential.digits_in_succession_max = 3
 
# If the stem of a filename ends with a pattern, that is similar to a copy
# counter, add this extra separator. It must be one of `TRIM_LINE_CHARS` (see
# definition in crate: `sanitize_filename_reader_friendly`) because they are
# known not to appear at the end of `sanitze()`'d strings. This is why they are
# suitable here.
copy_counter.extra_separator = "-"

# Tp-Note may add a counter at the end of the filename when it can not save a
# file because the name is taken already. This is the opening bracket search
# pattern. Some examples: `"-"`, "'_'"", `"_-"`,`"-_"`, `"("` Can be empty.
copy_counter.opening_brackets = "("

# Tp-Note may add a counter at the end of the filename when it can not save a
# file because the name is taken already. This is the closing bracket search
# pattern. Some examples: `"-"`, "'_'"", `"_-"`,`"-_"`, `"("` Can be empty.
copy_counter.closing_brackets = ")"

# File extension of new _Tp-Note_ files.
# NB: Do not forget to adapt the templates `tmpl.*` in case you set
# this to another markup language.
extension_default = "md"

# The variable `filename.extensions` list file extensions that Tp-Note
# considers as its own note files. Tp-Note opens these files, reads their
# YAML header and launches an external file editor and file viewer (web
# browser). According to the markup language used, the appropriate renderer
# is called to convert the note's content into HTML. Technically, the renderer
# is selected by the `markup_to_html` filter in `tmpl_html` templates. The 
# associated second value in the below list parametrizes the `markup_to_html` 
# filter. Currently, Tp-Note renders the following markup languages: 
# * `Markdown`, 
# * `Restructuredtext`, 
# * `Html`, 
# * `PlainText` and 
# * `PlainTextNoViewer`. 
# When the renderer is `PlainTextNoViewer`, the viewer is disabled for note
# files with this file extension. Otherwise, the rendered HTML is displayed to
# the user via his web browser.
# NB: The list is ordered to look for the most common extensions first.
extensions = [
  [ "txt", "Markdown" ],
  [ "md", "Markdown" ],
  [ "rst", "Restructuredtext" ],
  [ "htmlnote", "Html" ],
  [ "txtnote", "PlainText" ],
  [ "adoc", "PlainText" ],
  [ "text", "Markdown" ],
  [ "markdn", "Markdown" ],
  [ "markdown", "Markdown" ],
  [ "mdown", "Markdown" ],
  [ "mdtext", "Markdown" ],
  [ "mdtxt", "Markdown" ],
  [ "mdwn", "Markdown" ],
  [ "mkd", "Markdown" ],
  [ "rest", "Restructuredtext" ],
  [ "asciidoc", "PlainText" ],
  [ "mediawiki", "PlainTextNoViewer" ],
  [ "mw", "PlainTextNoViewer" ],
  [ "t2t", "PlainTextNoViewer" ],
]


[tmpl]

# After generating a new note with a content template, Tp-Note parses the
# resulting front matter into `fm_* variables and checks their values. The
# following conditions are checked and the user is prompted if one of them is
# not satisfied.
# The first item per line is the checked variable name, the following items
# are the applied tests:
# * `IsDefined`: Assert that the variable is defined in the template.
# * `IsString`: Assert, that if the variable is defined, its type -or all
#    subtypes- are `Value::String`.
# * `IsNotEmptyString`: In addition to `IsString`, the condition asserts, that 
#    the string -or all substrings-) are not empty.
# * `IsNumber`: Assert, that if the variable is defined, its type -or all
#    subtypes- are `Value::Number`.
# * `IsBool`: Assert, that if the variable is defined, its type -or all
#    subtypes- are `Value::Bool`.
# * `IsNotCompound`: Assert, that if the variable is defined, its type is not
#   `Value::Array` or `Value::Object`.
# * `IsValidSortTag`: Assert, that if the variable is defined, the value's
#    string representation contains solely characters of the
#    `filename.sort_tag.extra_chars` set, digits or lowercase letters.
#    The number of lowercase letters in a row is limited by
#    `tpnote_lib::config::FILENAME_SORT_TAG_LETTERS_IN_SUCCESSION_MAX`.
# * `IsTpnoteExtension`: Assert, that if the variable is defined, the values
#    string representation is registered in one of the `filename.extension_*`
#    configuraion file variables.
# * `NoOperation` (default): A test that is always satisfied. For internal use
#    only.
filter.assert_preconditions = [
    [ "fm_title", [ "IsDefined", "IsString", "IsNotEmptyString", "IsNotCompound"], ],
    [ "fm_subtitle", ["IsString", "IsNotCompound"], ],
    [ "fm_author", ["IsString"], ],
    [ "fm_lang", ["IsString"], ],
    [ "fm_sort_tag", ["IsNotCompound", "IsValidSortTag", ], ],
    [ "fm_file_ext", ["IsString", "IsNotCompound", "IsTpnoteExtension"], ],
    [ "fm_no_filename_sync", ["IsBool", "IsNotCompound"], ],
    [ "fm_filename_sync", ["IsBool", "IsNotCompound"], ],
]

# If the number, the `icr_sort_tag` filter extracted from its input, is 
# larger than this, then do not increment but return the default value instead.
# Values bigger than `9` have no effect, as the integers are stored in an `u32`.
filter.incr_sort_tag.default_if_greater = 2

# If the input of the `icr_sort_tag` filter contains one of these characters,
# then do not increment but return the default value instead.
filter.incr_sort_tag.default_if_contains = "-"

# A list of language tags, defining languages the `get_lang` filter tries
# to identify in its input. The user's default language subtag, as reported 
# from the operating system, is automatically added to the present list.
# The language recognition feature is disabled, when the list is empty.
# It is also disabled, when the user's default language, as reported from
# the operating system, is not supported by the external language guessing
# library _Lingua_. In both cases the filter returns the empty string.
filter.get_lang = [ "en", "fr", "de", ]

# Default values for the `map_lang` hash map filter, that are used to post
# process the language recognition subtag as defined in `filter.get_lang`. The
# key is the language subtag, the corresponding value adds a region subtag
# completing the language tag. The default region subtags are chosen to be
# compatible with the _LanguageTool_ grammar checker. In case a language
# subtag has no key in the present hash map, the filter forwards the input
# unchanged, e.g. the filter input `fr` results in `fr`.
# One entry, derived from the user's default language - as reported from the
# operating system - is automatically added to the present list. This
# happens only when this language is not listed yet. For example,
# consider the list `tmpl.filter.map_lang = &[&["en", "en-US"]]`: In this
# case, the user's default language `fr_CA.UTF-8` is added as
# `&["fr", "fr-CA"]`. But, if the user's default language were
# `en_GB.UTF-8`, then it is _not_ added because an entry `&["en", "en-US"]`
# exists already.
# Note, that the empty input string results in the user's default language
# tag - here `fr-CA` - as well.
filter.map_lang = [
    [ "de", "de-DE", ],
    [ "et", "et-ET", ],
]

# Default value used by `to_yaml_filter`.
# The parameter `tmpl.filter.to_yaml_tab = n` indents the YAML values
# `n` characters to the right of the first character of the key by inserting
# additional spaces between the key and the value. `n==0` disables the
# extra indentation.
filter.to_yaml_tab = 14

# Default content template used when the command line argument `<sanit>`
# is a directory. Can be changed through editing the configuration
# file. The following variables are defined:
# * `{{ path }}`: points to the directory where the new note will be created.
# * `{{ dir_path }}` is in this context identical to `{{Â path }}`.
#   In addition, all environment variables can be used, e.g.
#   `{{ get_env(name=\"LOGNAME\") }}` When placed in YAML front matter, the
#   filter `to_yaml` must be appended to each variable.
from_dir_content = """
{%- set title_text = dir_path | trim_file_sort_tag -%}
---
{{ title_text | cut | to_yaml(key='title') }}
{{ 'Note' | to_yaml(key='subtitle') }}
{{ username | capitalize | to_yaml(key='author') }}
{{ now() | date(format='%Y-%m-%d') | to_yaml(key='date') }}
{{ title_text | get_lang | map_lang(default=lang) | to_yaml(key='lang') }}
---


"""

# Default filename template for a new note file on disk. It implements the
# sync criteria for note metadata in front matter and filename.
# Useful variables in this context are:
# `{{ title | sanit }}`, `{{ subtitle | sanit }}`, `{{ extension_default }}.
# In general, in filename template, all variables (except `now` and
# `extension_default` must be filtered by a `sanit` filter.
from_dir_filename = """
{%- set tag_default = now() | date(format='%Y%m%d') -%}
{%- set tag = dir_path | find_last_created_file | incr_sort_tag(default=tag_default) -%}
{{ fm_title | sanit | prepend(with_sort_tag=tag) }}\
{{ fm_subtitle | default(value='') | sanit | prepend(with='--') }}\
{{ extension_default | prepend(with='.') }}"""

# Default template used, when the clipboard or the input stream `stdin`
# contains a string and one the of these strings contains a valid YAML front
# matter section. The clipboards body is in `{{ clipboard }}`, the header
# is in `{{ clipboard_header }}`.  The stdin's body is in `{{ stdin }}`,
# the header is in `{{ stdin_header }}`. First all variables defined in the
# clipboard's front matter are registered, the ones defined in the input
# stream `stdin`. The latter can overwrite the former.  One of the front
# matters must define the `title` variable, which is then available in this
# template as `{{ fm_title }}`.
# When placed in YAML front matter, the filter `to_yaml` must be
# appended to each variable.
from_clipboard_yaml_content = """
{%- set lang = fm_lang 
    | default(value = fm_title 
    | default(value=stdin~clipboard|heading) 
    | get_lang 
    | map_lang(default=lang) )  -%}
---
{{ fm_title | default(value = path|trim_file_sort_tag) | cut | to_yaml(key='title') }}
{{ fm_subtitle | default(value = 'Note') | cut | to_yaml(key='subtitle') }}
{{ fm_author | default(value=username | capitalize) | to_yaml(key='author') }}
{{ fm_date | default(value = now()|date(format='%Y-%m-%d')) | to_yaml(key='date') }}
{{ lang | to_yaml(key='lang') }}
{{ fm_all \
    | remove(key='fm_title')\
    | remove(key='fm_subtitle')\
    | remove(key='fm_author')\
    | remove(key='fm_date')\
    | remove(key='fm_lang')\
    | to_yaml \
    | prepend(newline=true) \
    | append(newline=true) }}\
---

{{ stdin ~ clipboard | trim }}

"""

# Default filename template used when the stdin or the clipboard contains a
# string and one of them has a valid YAML header.
from_clipboard_yaml_filename = """
{%- if fm_sort_tag -%}
  {%- set tag = fm_sort_tag -%}
{%- else -%}
  {%- set tag_default = now() | date(format='%Y%m%d') -%}
  {%- set tag = dir_path | find_last_created_file | incr_sort_tag(default=tag_default) -%}
{%- endif -%}

{{ fm_title | sanit | prepend(with_sort_tag=tag) }}\
{{ fm_subtitle | default(value='') | sanit | prepend(with='--') }}\
{{ fm_file_ext | default(value = extension_default ) | prepend(with='.') }}"""

# Default template used, when the clipboard or the input stream `stdin`
# contains a string and this string has no valid YAML front matter section.
# The clipboards content is in `{{ clipboard }}`, its truncated version in
# `{{ clipboard | heading }}` When the clipboard contains a hyperlink in
# Markdown or reStruncturedText format. See crate `parse-hyperlinks` for
# details. For example: `[<link-name>](<link-url> "link-title")`, can be
# accessed with the variables: `{{ clipboard | link_text }}`, `
# {{ clipboard | link_dest }}` and `{{ clipboard | linkttitle }}`.
from_clipboard_content = """
{%- set first_link = stdin ~ clipboard | link_text_picky -%}
{%- set first_lines = stdin ~ clipboard | heading -%}

{%- if first_link != '' -%} 
  {%- set title_text = first_link -%}
{%- else -%}
  {%- set title_text = first_lines -%}
{%- endif -%}

{% if first_link !='' and
          stdin ~ clipboard | cut | linebreaksbr == stdin ~ clipboard | cut -%}
  {%- set subtitle_text = 'URL' -%}
{%- else -%}
  {%- set subtitle_text = 'Note' -%}
{%- endif -%}
---
{{ title_text | cut | to_yaml(key='title') }}
{{ subtitle_text | to_yaml(key='subtitle') }}
{{ username | capitalize | to_yaml(key='author') }}
{{ now() | date(format='%Y-%m-%d') | to_yaml(key='date') }}
{{ title_text | get_lang | map_lang(default=lang) | to_yaml(key='lang') }}
---

{{ stdin ~ clipboard | trim }}

"""

# Default filename template used when the stdin ~ clipboard contains a string.
from_clipboard_filename = """
{%- set tag_default = now() | date(format='%Y%m%d') -%}
{%- set tag = dir_path | find_last_created_file | incr_sort_tag(default=tag_default) -%}
{{ fm_title | sanit | prepend(with_sort_tag=tag) }}\
{{ fm_subtitle | default(value='') | sanit | prepend(with='--') }}\
{{ extension_default | prepend(with='.') }}"""

# Default template used, when the opened text file (with a known file
# extension) is missing a YAML front matter section. This template prepends
# such a header. The template inserts information extracted from the input
# filename and its creation date. `{{ path }}` points to the text file,
# `{{ dir_path }}` to the directory where it is located.
from_text_file_content = """
---
{{ path | file_stem | split(pat='--') | first | cut | to_yaml(key='title') }}
{{ path | file_stem | split(pat='--') | nth(n=1) | cut | to_yaml(key='subtitle') }}
{{ username | capitalize | to_yaml(key='author') }}
{{ doc_file_date | default(value='') | date(format='%Y-%m-%d') | to_yaml(key='date') }}
{{ doc_body_text | get_lang | map_lang(default=lang) | to_yaml(key='lang') }}
# {{ path | file_name | to_yaml(key='orig_name', tab=12) }}
---

{{ doc_body_text }}
"""

# Default filename template used when the input file (with a known
# file extension) is missing a YAML front matter section.
# The text file's sort-tag and file extension are preserved.
from_text_file_filename = """
{%- if path | file_sort_tag != '' -%}
  {%- set tag = path | file_sort_tag -%}
{%- else -%}
  {%- set tag = doc_file_date | date(format='%Y%m%d') -%}
{%- endif -%}
{{ fm_title | sanit | prepend(with_sort_tag=tag) }}\
{{ fm_subtitle | default(value='') | sanit | prepend(with='--') }}\
{{ path | file_ext | prepend(with='.') }}"""

# Default template used when the command line `<path>` parameter points to an
# existing - to be annotated - non-`.md`-file. `{{ path}}` points to that
# file, `{{ dir_path }}` to the directory where it is located.
annotate_file_content = """
{%- set body_text = stdin ~ clipboard | trim -%}
{%- if body_text != '' -%}
   {%- set lang_test_text = body_text | cut -%}
{%- else -%}
   {%- set lang_test_text = path | file_stem  -%}
{%- endif -%}
---
{{ path | trim_file_sort_tag | to_yaml(key='title') }}
{% if body_text | link_text !='' and
      body_text | heading == body_text -%}
{{ 'URL' | to_yaml(key='subtitle') -}}
{%- else -%}
{{ 'Note' | to_yaml(key='subtitle') -}}
{%- endif %}
{{ username | capitalize | to_yaml(key='author') }}
{{ now() | date(format='%Y-%m-%d') | to_yaml(key='date') }}
{{ lang_test_text | get_lang | map_lang(default=lang) | to_yaml(key='lang') }}
---

[{{ path | file_name }}](<{{ path | file_name }}>)
{% if body_text != '' -%}
{%- if body_text != body_text | heading %}
---
{% endif %}
{{ body_text }}
{% endif %}
"""

# Filename of a new note, that annotates an existing file on disk given in
# `<path>`.
annotate_file_filename = """
{%- set tag = path | file_sort_tag -%}
{{ fm_title | sanit | prepend(with_sort_tag=tag) }}\
{{ fm_subtitle | default(value='') | sanit | prepend(with='--') }}\
{{ extension_default | prepend(with='.') }}"""

# Default filename template to test, if the filename of an existing note file
# on disk, corresponds to the note's meta data stored in its front matter. If
# it is not the case, the note's filename will be renamed.
sync_filename = """
{%- if fm_filename_scheme | default(value='default') != 'default' \
       and throw(message='This template accepts only: `filename_scheme: default`') -%}
{%- endif -%}
{%- set tag = fm_sort_tag | default(value = path | file_sort_tag) | as_str -%}
{{ fm_title | default(value='No title') | sanit | prepend(with_sort_tag=tag) }}\
{{ fm_subtitle | default(value='') | sanit | prepend(with='--') }}\
{{ fm_file_ext | default(value = path | file_ext) | prepend(with='.') }}
"""

[tmpl_html]

# HTML template to render regular viewer pages. Note: HTML templates escape HTML
# critical symbols by default. To disable this feature for a specific variable,
# add a `safe` filter in last position.
viewer = '''
{%- set ext = fm_file_ext | default(value=path|file_ext) -%}
<!DOCTYPE html>
<html lang="{{ fm_lang | default(value='en') }}">
<head>
<meta charset="UTF-8">
<title>{{ fm_title }}</title>
<link rel="stylesheet" href="{{ viewer_doc_css_path }}">
<link rel="stylesheet" href="{{ viewer_highlighting_css_path }}">
<style>
<!-- Customize the viewer CSS here -->
</style>
</head>
<body>
  <table class="fm">
    <tr>
    <th class="fmkey">title:</th>
    <th class="fmval"><b>{{ fm_title | default(value='') | to_html | safe }}</b></th>
  </tr>
    <tr>
    <th class="fmkey">subtitle:</th>
    <th class="fmval">{{ fm_subtitle | default(value='') | to_html | safe }}</th>
  </tr>
    <tr>
    <th class="fmkeygrey">author:</th>
    <th class="fmvalgrey">{{ fm_author | default(value='') |to_html | safe }}</th>
  </tr>
    <tr>
    <th class="fmkeygrey">date:</th>
    <th class="fmvalgrey">{{ fm_date | default(value='')| to_html | safe }}</th>
  </tr>
    <tr>
    <th class="fmkeygrey">lang:</th>
    <th class="fmvalgrey">{{ fm_lang | default(value='') |to_html | safe }}</th>
  </tr>
  {% if fm_all | length > 5 %}
    <tr><th colspan=2;\"/>&nbsp<th/</tr>
  {% endif %}
  {% for k, v in fm_all| remove(key='fm_title')|
                         remove(key='fm_subtitle')|
                         remove(key='fm_author')|
                         remove(key='fm_date')|
                         remove(key='fm_lang')
  %}
    <tr>
    <th class="fmkeygrey">{{ k }}:</th>
    <th class="fmvalgrey">{{ v | to_html | safe }}</th>
  </tr>
  {% endfor %}
  </table>
  <div class="doc-body">{{ doc_body_text | markup_to_html(extension=ext) | safe }}
  </div>
  <script>{{ viewer_doc_js | safe }}</script>
</body>
</html>
'''

# HTML template to render the viewer-error page.
viewer_error = """
<!DOCTYPE html>
<html lang=\"en\">
<head>
<meta charset=\"UTF-8\">
<title>Syntax error</title>
<style>
.note-error { color: #523626; }
pre { white-space: pre-wrap; }
a { color: #316128; }
h1, h2, h3, h4, h5, h6 { color: #d3af2c; font-family:sans-serif; }
</style>
</head>
<body>
<h3>Syntax error</h3>
<p> in note file: <pre>{{ path }}</pre><p>
<div class=\"note-error\">
<hr>
<pre>{{ doc_error }}</pre>
<hr>
</div>
{{ doc_text | markup_to_html | safe }}
<script>{{ viewer_doc_js | safe }}</script>
</body>
</html>
"""

# A constant holding common CSS code, published by Tp-Note's viewer under the
# `/viewer_doc.css` path.
viewer_doc_css = """
/* Tp-Note's viewer document CSS */
table.fm {
  font-weight: normal;
  margin-left: auto;
  margin-right: auto;
  padding: 4px;
  background-color: #f3f2e4;
  border:1px solid grey;
}
th.fmkey, th.fmkeygrey {
  font-weight: normal;
  padding-left:20px;
  padding-right:10px;
}
th.fmval, th.fmvalgrey {
  font-weight: normal;
  padding-left:10px;
  padding-right:20px;
}
th.fmkey{ color:#444444; text-align:right; vertical-align:top;}
th.fmval{
  color:#316128;
  text-align:left;
  font-family:sans-serif;
}
th.fmkeygrey{ color:grey; text-align:right; vertical-align:top;}
th.fmvalgrey{ color:grey; text-align:left; }
ul.fm {
  padding-left: 15px;
  margin: 0px;
}
li.fm {
  padding-bottom: 0px;
}
blockquote.fm {
  margin: 0px;
  padding-left: 15px
}
pre { white-space: pre-wrap; }
em { color: #523626; }
a { color: #316128; }
h1 { font-size: 150% }
h2 { font-size: 132% }
h3 { font-size: 115% }
h4, h5, h6 { font-size: 100% }
h1, h2, h3, h4, h5, h6 { color: #263292; font-family:sans-serif; }
"""

# Loads the viewer's code syntax highlighting theme. The theme is converted
# into additional CSS. Currently available are:
# * `base16-ocean.dark`
# * `base16-eighties.dark`
# * `base16-mocha.dark`
# * `base16-ocean.light`
# * `InspiredGitHub`
# * `Solarized (dark)`
# * `Solarized (light)`
viewer_highlighting_theme = "Solarized (light)"

# HTML template used to render a note into HTML when the rendition is saved to
# disk. Similar to `tmpl_html.viewer` but does not inject JavaScript code.
exporter = '''
{%- set ext = fm_file_ext | default(value=path|file_ext) -%}
<!DOCTYPE html>
<html lang="{{ fm_lang | default(value='en') }}">
<head>
<meta charset="utf-8">
<title>{{ fm_title }}</title>
<style>
{{ exporter_doc_css | safe }}
{{ exporter_highlighting_css | safe }}
<!-- Customize the exporter CSS here -->
</style>
</head>
<body>
  <table class="fm">
    <tr>
    <th class="fmkey">title:</th>
    <th class="fmval"><b>{{ fm_title| default(value='') | to_html | safe }}</b></th>
  </tr>
    <tr>
    <th class="fmkey">subtitle:</th>
    <th class="fmval">{{ fm_subtitle | default(value='') | to_html | safe }}</th>
  </tr>
    <tr>
    <th class="fmkeygrey">author:</th>
    <th class="fmvalgrey">{{ fm_author | default(value='') |to_html | safe }}</th>
  </tr>
    <tr>
    <th class="fmkeygrey">date:</th>
    <th class="fmvalgrey">{{ fm_date | default(value='')| to_html | safe }}</th>
  </tr>
    <tr>
    <th class="fmkeygrey">lang:</th>
    <th class="fmvalgrey">{{ fm_lang | default(value='') |to_html | safe }}</th>
  </tr>
  {% if fm_all | length > 5 %}
    <tr><th colspan=2;\"/>&nbsp<th/</tr>
  {% endif %}
  {% for k, v in fm_all| remove(key='fm_title')|
                         remove(key='fm_subtitle')|
                         remove(key='fm_author')|
                         remove(key='fm_date')|
                         remove(key='fm_lang')
  %}
    <tr>
    <th class="fmkeygrey">{{ k }}:</th>
    <th class="fmvalgrey">{{ v | to_html | safe }}</th>
  </tr>
  {% endfor %}
  </table>
  <div class="doc-body">{{ doc_body_text| markup_to_html(extension=ext) | safe }}
  </div>
</body>
</html>
'''

# Loads the exporter's code syntax highlighting theme. The theme is converted
# into additional CSS. Currently available are:
# * `base16-ocean.dark`
# * `base16-eighties.dark`
# * `base16-mocha.dark`
# * `base16-ocean.light`
# * `InspiredGitHub`
# * `Solarized (dark)`
# * `Solarized (light)`
exporter_highlighting_theme = "Solarized (light)"

# A constant holding common CSS code, inserted into exported HTML documents
# with the template variable `{{ exporter_doc.css }}`. 
exporter_doc_css = """
/* Tp-Note's exporter document CSS */
table.fm {
  font-weight: normal;
  margin-left: auto;
  margin-right: auto;
  padding: 4px;
  background-color: #f3f2e4;
  border:1px solid grey;
}
th.fmkey, th.fmkeygrey {
  font-weight: normal;
  padding-left:20px;
  padding-right:10px;
}
th.fmval, th.fmvalgrey {
  font-weight: normal;
  padding-left:10px;
  padding-right:20px;
}
th.fmkey{ color:#444444; text-align:right; vertical-align:top;}
th.fmval{
  color:#316128;
  text-align:left;
  font-family:sans-serif;
}
th.fmkeygrey{ color:grey; text-align:right; vertical-align:top;}
th.fmvalgrey{ color:grey; text-align:left; }
ul.fm {
  padding-left: 15px;
  margin: 0px;
}
li.fm {
  padding-bottom: 0px;
}
blockquote.fm {
  margin: 0px;
  padding-left: 15px
}
pre { white-space: pre-wrap; }
em { color: #523626; }
a { color: #316128; }
h1 { font-size: 150% }
h2 { font-size: 132% }
h3 { font-size: 115% }
h4, h5, h6 { font-size: 100% }
h1, h2, h3, h4, h5, h6 { color: #263292; font-family:sans-serif; }
"""
